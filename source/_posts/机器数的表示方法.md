---
title: 机器数的表示方法
date: 2020-03-12 14:38:26
tags: [计算机组成原理, 笔记]
categories:  计算机组成原理
index_img: /img/计算机组成原理/header1.png
---

包括原码、反码、补码、移码的一些操作。
<!-- more -->
# 原码
用最高位表示符号（0——正，1——负），其他位表示数值的绝对值

>例如：
x1=+45 ===> [x1]~原~ = <font color=red>0</font>0101101B
x2= -45 ===> [x2]~原~ = <font color=red>1</font>0101101B

在原码中，0的表示不唯一
[+0]~原~ = <font color=red>0</font>0000000B
[- 0]~原~ = <font color=red>1</font>0000000B

# 反码
- 用最高位表示符号（0——正，1——负）
- <font color=blue>正数</font>的反码：与原码相同
- <font color=blue>负数</font>的反码：符号位不变，其余位按位取反

>例如：
x1=+45 ===> [x1]~原~ = <font color=red>0</font>0101101B ===> [x1]~反~ = <font color=red>0</font>0101101B
x2= -45 ===> [x2]~原~ = <font color=red>1</font>0101101B ===> [x2]~反~ = <font color=red>1</font>1010010B

在反码中，0的表示不唯一
[+0]~反~ = <font color=red>0</font>0000000B
[- 0]~反~ = <font color=red>1</font>1111111B

# :star:补码
- 用最高位表示符号（0——正，1——负）

在补码中，0的表示唯一
[+0]~补~ = <font color=red>0</font>0000000B
[- 0]~补~ = <font color=red>0</font>0000000B

所以将剩下的[100.....0]位表示为最大负数，-2^n^

## 补码的几种计算方式

本例中的取反+1等效于-1取反

**第一种方法**
- 正数的补码：和原码相同
- 负数的补码：符号位不变，==数值位按位取反== ，末位+1

>例如：
x1=+45 ===> [x1]~原~ = <font color=red>0</font>0101101B ===> [x1]~补~ = <font color=red>0</font>0101101B
x2= -45 ===> [x2]~原~ = <font color=red>1</font>0101101B ===> [x2]~补~ = <font color=red>1</font>1010011B

**第二种方法**
- 正数的补码：和原码相同
- 负数的补码：从最低位（最右侧）起，到出现第一个1以前原码中的数字不变，以后逐位取反，符号位不变。

>例如：
x1=-101 0111B  &emsp; X2=-111 0000B
[x1]~原~ = <font color=red>1</font>101 011<font color=red>1</font>B ===> [x1]~补~ = <font color=red>1</font>010 100<font color=red>1</font>B
//最右侧起第一个1是右侧第一位，所以从右侧第二位起到符号位为止，中间的位全部取反<br />
[x2]~原~ = <font color=red>1</font>11<font color=red>1 0000</font>B ===> [x2]~补~ = <font color=red>1</font>00<font color=red>1 0000</font>B
//最右侧起第一个1是右侧第5位，所以从右侧第一位到第五位不变，第六位起到符号位为止，中间全部取反

**第三种方法**
- 正数的补码：和原码相同
- 负数的补码：相对应的正数的补码全部取反（包括符号位），在末位+1

>例如：
[x1] = -45 &emsp;[-x1] = +45
[-x1]~补~ = [-x1]~原~ = <font color=red>0</font>010 1101B
[x1]~补~ = <font color=red>1</font>1010011B

<p class="note note-primary">同样的，[-x1]<sub>补</sub>也可以通过[x1]<sub>补</sub>全部取反+1得到，说明一个数的正负补码可以互相通过全部位取反+1得到</p>

>例如：
已知一个数的补码为[1101 0011B]，那么由符号位为1可知该数为负，其正数的补码由全部位取反+1得到，为[0010 1101B]，算出十进制数为+45（相当于该数绝对值为45），已知原数为负，所以该数为-45.

**第四种方法**
- 正数的补码：和原码相同
- 负数的补码：【2^n^-|x|】的补（原）码（因为是正数）

>例如：
求-7的补码，因为-7需要四位二进制表示[1111B]，所以2^n^=2^4^=16
那么2^4^-|-7|=9，所以-7的补码就是9的补码，即1001B

## 补码的运算
**补码的符号位也参与运算**
加法：[X+Y]~补~ = [X]~补~ + [Y]~补~
减法：[X-Y]~补~ = [X]~补~ + [-Y]~补~

## 补码的算术移位

符号位在移位时不变，正数左右移位都补0，负数向右移位空来的位补1，左移空出来的位补0

>例如：
[X]~原~ = 1001 ==> [x]~补~ = 1111
右移一位（相当于除以2（位数越高越接近除以2））：1111 -> 1111 = 1001 = -1，因为1除以2余1
左移一位（相当于乘以2，同理）：1111 -> 1110 = 1010 = -2

✨当符号位与最高位（最左位）不同时，左移会溢出

>例如：
0.1101~[补]~ = 0.1101~[原]~ = +13
那么左移乘以2应该为26，但26无法用4位二进制表示，所以溢出
0.1101左移后为0.1010 = +12 != 26<br />
1.0110~[补]~ = 1.1010~[原]~ = -10
那么左移乘以2应该为-20，同样无法用4位二进制表示，所以溢出
1.0110左移后为1.1100~[补]~ = 1.0101~[原]~ = -5 != -20

# 移码
- 定义：[X]~移~ = 2^n^ +X (-2^n^ <= X <= 2^n^-1)
- 用最高位表示符号，其中1——正，0——负
- 移码的计算方法：补码的符号位取反，数值位不变

>例如：
x = -4, [x]~原~ = 1100 -> [x]~补~ = 1100 -> [x]~移~ = 0100
or
2^n^ = 2^3^ = 8 = 1000, [x]~移~ = [8]~原~ + [x]~原~ = 1000+1100 = 0100

- 真值越大，对应的移码也越大
 
在移码中，0的表示是唯一的
[x]~移~ = 2^n^+0 = 1000....0 

**移码的加减运算**
加法：[X]~移~ + [Y]~移~ = [X+Y]~补~ 然后符号位取反
减法：[X]~移~ - [Y]~移~ = [X-Y]~补~ 然后符号位取反

