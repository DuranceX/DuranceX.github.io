---
title: 第二章：数据表示与逻辑电路基础
date: 2020-02-26 17:23:21
tags: [计算机组成原理, 笔记]
categories: 计算机组成原理
index_img: /img/计算机组成原理/header.png
math: true
---
计算机组成原理——第二章：数据表示与逻辑电路基础
包括机器数、定点与浮点数、数据校验、奇偶校验、CRC校验和海明校验等内容

<!-- more -->

# 一、机器数及其特点
[具体介绍](https://skyhouse.xyz/2020/03/12/机器数的表示方法/)

## 机器内的数据表示
1. 真值：符号用“+”，“-”表示的数据表示方法
2. 机器数：符号数值化的数据表示方法，用0、1表示符号（二进制）
3. 四种常见的机器数：原码，反码，补码，移码
设定点数的形式为$X_0X_1X_2X_3...X_n$
![](/img/计算机组成原理/机器数.png)
计算起来就是反码是原码取反（0->1,1->0，符号除外）
补码就是反码+1
移码的数值位与补码相同，符号位与补码相反
    >因此不能说“0”代表正号，“1”代表负号，因为在补码中如此，但在移码中相反
    >例如：
    (1)X=+1011
    [X]~原~=[X]~反~=[X]~补~=01011
    (2)X=-1011
    [X]~原~=11011 &nbsp;&nbsp;&nbsp;&nbsp; [X]~反~=10100  &nbsp;&nbsp;&nbsp;&nbsp; [X]~补~=10101
    (3)0的表示
    [+0]~原~=00000 &nbsp;&nbsp;&nbsp;&nbsp; [-0]~原~=10000
    [+0]~反~=00000 &nbsp;&nbsp;&nbsp;&nbsp; [-0]~反~=11111
    [+0]~补~=00000=[-0]~补~ 
    >> 机器数表示的范围受字长的限制
    原码和反码的0有两种表现形式；补码和移码的0只有1种表现形式

1. 反码的运算
   两个二进制数反码相加，最后得到的位数若大于两数的位数，则第一位加至最后一位
   >例：
   x=-1101，Y=-1010，则[X+Y]~反~为
    ![](/img/计算机组成原理/反码运算.png)


# 二、定点与浮点数据表示
[具体介绍](https://skyhouse.xyz/2020/03/12/定点数与浮点数/)
## 定点数
![](/img/计算机组成原理/定点数.png)
可见定点小数的的小数点在数字中间，定点整数的小数点在数字最后

## 浮点数

浮点数是把数的范围和精度分别表示的一种数据表示方法

1. 一般格式
   ![](/img/计算机组成原理/浮点数一般格式.png)
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当计算机的字长确定时，分给阶码部分的位越多，数据表示的范围就越大，与此同时数据的精确度会下降

2. IEEE 754格式
   ![](/img/计算机组成原理/IEEE-754.png)
   IEEE 754格式与对应真值之间的变换流程如下
   ![](/img/计算机组成原理/IEEE转换.png)

   >例：
    将二进制数20.59375转换成32位IEEE754格式浮点数的二进制格式
    ![](/img/计算机组成原理/DECtoIEEE.png)
    IEEE754浮点数$ｘ$的二进制存储格式为(41360000)H，其对应的十进制值为？
    ![](/img/计算机组成原理/IEEEtoDEC.png)
    >>小数的原码计算方式：
    小数项×2取整数部分，直到小数部分为0
    例：0.375的小数表示过程
    0.375 * 2 = 0.75 -------------- 0
    0.75 &nbsp;&nbsp;* 2 = 1.5  &nbsp;&nbsp;-------------- 1 
    0.5 &nbsp;&nbsp;&nbsp; * 2 = 1 &nbsp;&nbsp;&nbsp;&nbsp; -------------- 1
    所以0.375的二进制表示为.011
    反之：
    例：.011的十进制表示过程
    0 * 10^-1^ + 1 * 10^-2^ + 1 * 10^-3^ =0.375


# 三、数据校验的基本原理

校验的基本原理是添加冗余码（校验位）
形成 **[有效信息(k位)+校验信息(r )位]** 的格式

码距：两个合法代码对应位上编码不同的位数称为码距
例如：10101和00110从第一位开始依次有第一位、第四、第五位不同，则码距为3
一组数中取码距最小的两对数的码距

|  码距  | 检错  | 纠错  |
| :----: | :---: | :---: |
|   1    |   0   |   0   |
|   2    |   1   |   0   |
|   3    |   2   |  或1  |
|   4    |   2   |  加1  |
|   5    |   2   |  加2  |
|   6    |   3   |  加2  |
|   7    |   3   |  加3  |
| ...... |       |       |

三个公式：
1. 码距>=$e$+1 ——>可检测e个错误
2. 码距>=2$t$+1 ——>可纠正t个错误
3. 码距>=$e$+$t$+1 ——>可纠正t个错误，同时检测e个错误（e>=t）

# 四、奇偶校验

## 基础知识

奇偶校验的原理同样是通过增加冗余码（校验位）来进行错误校验，奇偶校验的冗余码位数为一，
形成 **[有效信息(k位)+校验信息(r=1)位]** 的格式
通过增加的这个冗余码，使得整个编码中1的个数满足奇/偶校验的要求，如下
0001->0001<b><font color=blue>1</font></b> (偶校验)  $P=D$~1~$⊕D$~1~$⊕D$~2~$⊕D$~3~$⊕D$~n~

0001->0001<b><font color=blue>0</font></b> (奇校验)  $P=$ $\overline{D_1⊕D_2⊕D_3⊕D_n}$ 

第一个式子中总共有两个1，所以是偶校验，第二个式子中总共有一个1，所以是奇校验

奇偶校验的编码与检错简单，编码效率高，但是它**不能检测偶数位**错误，所以它的无措结论是不可靠的，但是**只有一位编码错误**的时候，奇偶校验的检错率是100%，肯定能够检测出来。

奇偶校验只能检测一位错误，并且没有纠错能力，因此奇偶校验的码距是2
<hr />

## 改进的奇/偶校验

改进后的奇/偶校验又称为双向奇偶校验、方块校验、垂直水平校验等
![](/img/计算机组成原理/双向奇偶校验.png)
即在原有的一列奇偶校验码的基础上再添加一行奇偶校验码
这种校验方式可以**检测并纠正**一位错误，可以检测某行（列）上的奇数位错误，可以检测出一部分偶数位错误，不能检测出分布在矩形四个顶点上的错误。

> 一般在同步传输方式中常采用奇校验，异步传输中常采用偶校验


# 五、CRC校验（循环冗余校验）

## 基础知识

CRC校验的校验码的位数由一个公式得到$N=k+r\leq2^r-1$，其中
   - $r$表示校验位数
   - $k$表示有效信息位数
   - $2^r-1$表示可以表现的错误总数（总共$2^r$种情况，其中一种是正确无错误）
格式仍然为 **[有效信息(k位)+校验信息(r )位]**

CRC校验中存在一个生成多项式$G(x)$,概念为:收发双方约定的一个 **(r+1)** 位二进制数，发送方利用$G(x)$对信息多项式做模2除运算，生成校验码。接收方利用$G(x)$对收到的编码多项式做模2除运算检测差错及错误定位

$G(x)$应该满足以下特点
   1. 最高位和最低位必须为1
   2. 当被传送信息（CRC码）任何一位发生错误时，被生成多项式做除后应该使余数不为0
   3. 不同位发生错误时，模2除运算后余数不同
   4. 对不为0余数继续进行模2除运算应使余数循环

以下为常见的生成多项式$G(x)$
(N=k+r)

|   N   |   K   | 码距d |           G(x)多项式           |          G(x) |
| :---: | :---: | :---: | :----------------------------: | ------------: |
|   7   |   4   |   3   |           $x^2+x+1$            |          1011 |
|   7   |   4   |   3   |          $x^3+x^2+1$           |          1101 |
|   7   |   3   |   4   |        $x^4+x^3+x^2+1$         |         11101 |
|   7   |   3   |   4   |       $x^4+x^2+x^2+x+1$        |         10111 |
|  15   |  11   |   3   |           $x^4+x+1$            |         10011 |
|  15   |   7   |   5   |      $x^8+x^7+x^6+x^4+1$       |     111010001 |
|  31   |  26   |   3   |          $x^5+x^2+1$           |        100101 |
|  31   |  21   |   5   | $x^{10}+x^9+x^8+x^6+x^5+x^3+1$ |   11101101001 |
|  63   |  57   |   3   |           $x^6+x+1$            |       1000011 |
|  63   |  51   |   5   | $x^{12}+x^{10}+x^5+x^4+x^2+1$  | 1010000110101 |

> 一般情况下使用的都是1011

<hr />

## 模2除运算

1. 加/减运算（异或运算，相同为0，不同为1）
   0 $\pm$ 0=0，0 $\pm$ 1=1，1 $\pm$ 0=1，1 $\pm$ 1=0
2. 模2除法（见下）
   ![](/img/计算机组成原理/模2运算.png)

<hr />

## CRC编码
1. 根据待校验信息的长度$k$，按照 $k+r\leq2^r-1$ 确定校验位$r$的位数
   如对4位信息1100进行CRC编码，根据公式得r~min~=3
2. 根据$r$和生成多项式得选择原则，选择位数为$r+1$的生成多项式G(x)=1011
3. 进行下列变化
   **[有效信息(k位)+校验信息(r 位)]** --->  **1100 000**
   > 即先把校验位全设0，得Q(x)
4. 对得到的Q(x)进行模2除运算
   ![](/img/计算机组成原理/CRC编码.png)
5. 用得到的余数替换校验位，得到最后的CRC编码为
   **[有效信息(k位)+校验信息(r 位)]** --->  **1100 000** ---> **1100 010**


## CRC检错与纠错

对得到校验码(即二进制编码数)，用G(x)作模2除，若得到一个不为0的余数，则说明信息出错了。
**进行纠错**
若余数不为0，若余数首位为1，则补零进行模2除，得到余数；若余数首位为0，则其剩下三位为余数，同时将被检测的校验码循环左移一位，由此得到第二个余数，直到余数为101时，说明此时的出错位已经移动到了最左端，将此时校验码的最左端数字取反，然后继续循环左移，直到移动位数之和为7，说明纠错完毕，出错位回到原位。例如一开始移动了4位，取反后继续移动3位。具体示例如下：
![](/img/计算机组成原理/CRC纠错.png)

进行模2除运算得到的余数是循环的，顺序为：011->110->111->101->001->010->100->011

> CRC校验得到的无措结论不一定是正确的

# 六、海明校验

海明校验的格式跟CRC校验相同
CRC校验的校验码的位数由一个公式得到$N=k+r\leq2^r-1$，其中
   - $r$表示校验位数
   - $k$表示有效信息位数
   - $2^r-1$表示可以表现的错误总数（总共$2^r$种情况，其中一种是正确无错误）
  
在海明编码中存在两种数据，分别称为校验位和数据位，其中校验位的位数为$r$所表示的数字，设$k+r$位海明码从左到右依次为第1，2，3，4......k+r位，r位校验位记为$P_i$(i=1,2,3.....,r)，分别位于k+r位海明编码的第 **2^i-1^**(i=1,2,3....,r)位上，其余位依次放置被校验的数据位，记为$b_i$(i=1,2,3.....,r)

例如：海明校验码中校验位和数据位的排列如下
![](/img/计算机组成原理/海明编码示例.png)

$H_j$位的数据被编号小于j的若干个海明位号之和等于j的校验位所校验，如：

Hi|<font color=red>1</font>|<font color=red>2</font>|3|<font color=red>4</font>|5|6|7|<font color=red>8</font>|9|10|11
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
||1|2|1,2|4|1,4|2,4|1,2,4|8|1,8|2,8|1,2,8
||P1|P2|b1|P3|b2|b3|b4|P4|b5|b6|b7

得出：任何一位有效数据位至少被两位校验位所校验
用偶校验计算出$P_1$~$P_4$四个校验位的值：
P1=b1 $⊕$ b2 $⊕$ b4 $⊕$ b5 $⊕$ b7
P2=b1 $⊕$ b3 $⊕$ b4 $⊕$ b6 $⊕$ b7
P3=b2 $⊕$ b3 $⊕$ b4
P4=b5 $⊕$ b6 $⊕$ b7
指错字G由校验位和被其校验的数据位依次做异或运算得到。
得指错字G~4~G~3~G~2~G~1~为：
G~4~=P4 $⊕$ b5 $⊕$ b6 $⊕$ b7
G~3~=P3 $⊕$ b2 $⊕$ b3 $⊕$ b4
G~2~=P2 $⊕$ b1 $⊕$ b3 $⊕$ b4 $⊕$ b6 $⊕$ b7
G~1~=P1 $⊕$ b1 $⊕$ b2 $⊕$ b4 $⊕$ b5 $⊕$ b7
若G~4~G~3~G~2~G~1~为0，则表明数据没有出错，反之其十进制值为出错的海明吗位号。例题如下：
![](/img/计算机组成原理/海明编码检错.png)
如上图所示的H=<font color=blue>0</font><font color=blue>1</font>1<font color=blue>0</font>011<font color=blue>0</font>000为例
- 指错字G~4~G~3~G~2~G~1~=0000，不一定说明无错
  例如P1、b1、P2三位同时出错，则G~4~G~3~G~2~G~1~依然为0
- 一位错和两位错不能由指错字区别
  如b1、b2同时出错，与仅b3出错时的指错字均为G~4~G~3~G~2~G~1~=0110
