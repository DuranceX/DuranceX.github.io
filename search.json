[{"title":"tensorflow报错","date":"2020-10-23T04:26:23.000Z","url":"/2020/10/23/tensorflow%E6%8A%A5%E9%94%99/","tags":[["problems","/tags/problems/"]],"categories":[["problems","/categories/problems/"]],"content":"tensorflow报错UnknownError: Failed to get convolution algorithm. This is probably because cuDNN failed to initialize, so try looking to see if a warning log message was printed above. 问题 在运行tensorflow时出现报错信息UnknownError: Failed to get convolution algorithm. This is probably because cuDNN failed to initialize, so try looking to see if a warning log message was printed above. 解决方法 方法一： 在项目中添加 可以正常运行，但此时没有使用GPU，而是使用的CPU进行运算 方法二： 重新安装cuDNN，在官网上下载对应的cuDNN版本，解压，将文件夹内的所有文件复制到CUDA安装目录C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.0下 再次运行可正常使用GPU进行运算"},{"title":"anaconda导入模块报错","date":"2020-10-23T03:45:08.000Z","url":"/2020/10/23/anaconda%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E6%8A%A5%E9%94%99/","tags":[["problems","/tags/problems/"]],"categories":[["problems","/categories/problems/"]],"content":"Anaconda导入模块报错UserWarning: mkl-service package failed to import 问题 用新安装的anaconda运行之前的程序报错UserWarning: mkl-service package failed to import无法导入numpy，提示DLL错误 解决 是环境变量的配置问题，因为重新安装了anaconda所以环境变量没有配置 在环境变量中上半部分的用户变量中的path中添加下列路径 视具体类路径而言，总之就是anaconda的安装文件夹和其下的Library\\bin文件夹"},{"title":"Ubuntu下安装向日葵远程软件","date":"2020-10-19T01:02:56.000Z","url":"/2020/10/19/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E5%90%91%E6%97%A5%E8%91%B5%E8%BF%9C%E7%A8%8B%E8%BD%AF%E4%BB%B6/","tags":[["problems","/tags/problems/"]],"categories":[["problems","/categories/problems/"]],"content":"在Ubuntu 20.04下安装向日葵远程软件。 先在向日葵官网下载对应的.deb文件，然后在终端中执行 此时可能会报错说缺少 libwebkitgtk-3.0-0如下图所示： 解决方法： 打开系统的源列表文件 添加一项 然后再执行下列操作 然后找到向日葵打开即可运行。 "},{"title":"Surface Go2 使用体验","date":"2020-07-28T09:00:09.000Z","url":"/2020/07/28/Surface-Go2-%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"],["Surface","/tags/Surface/"]],"categories":[["杂谈","/categories/%E6%9D%82%E8%B0%88/"]],"content":" Surface Go2 使用体验 关于这些天surface go2的使用体验，大致感受 购入 购买Surface Go2大概是在6.15号，是的，在618前夕，考虑到平时上课的记笔记功能以及网课考试开卷的形式，最终购买了Surface Go2. 说起来买平板的想法一开始还是来源于在平时上课，邻座大佬用的Ipad记笔记貌似还挺香的，就有了买个平板的想法，但也仅限于想法。真的想买还是因为这次的网课，网课有了ppt，自然也方便做些笔记，但没有触屏写字的功能，用键盘输入，emmm，排版不佳，书写僵硬；用鼠标写字，emmm，效率低下，要多别扭有多别扭。因为就寻思着买个平板了。有考虑过Surface Pro，Ipad等，但最后根据需求还是买了Surface Go2（不还是因为没钱🤦‍♂️） 一开始想买那会儿Go2还没出，但是有传闻（只不过从19年就开始传了，也没见成），看看Go的飞机场边框又有点让人望而却步，再加上Go2说不定呢，最终也是犹犹豫豫没买。后来终于，微软悄无声息地上架了Surface Go2，一阵激动，看看美区商店的价格也还能接受，首发优惠+学生折扣+翻新说不定还能整个i3的版本（当然后来发现这是我想多了。。。翻新哪有那么快😓），本想着国区跟美区应该同步，结果美区都发售了国区还没个消息，最后终于公布时还莫得首发优惠，贵了一大截，最后还是走了某宝🤪 奔腾版Go2+亮银色欧缔兰键盘盖+黑色Surface Pen，4500左右，还能接受，给了一坨赠品，什么保护膜之类的，为了体验原生手感全部没用，丢在一旁吃灰。 啊？你问我为什么不买Ipad啊。可能果黑+田字信仰吧，再加上毫无苹果设备，懒得入苹果生态了。（而且surface好看啊，这个支架更是香🤪） 总览 先整个全家福吧。 开箱后大致观感还是不错的，边框相较于一代还是有提升。欧缔兰材质的键盘手感确实不错，整个键盘的键程也是，手感挺棒，不过确实需要适应一下，毕竟小了一号😂（用到现在感觉这个材质键盘舒服是舒服。。。就是脏了不知道怎么洗。。。头疼） 机身 机身的接口不多，一个Microsoft的磁吸充电孔，一个Type-C接口，一个3.5毫米耳机孔，没了。或者再加个存储卡的插槽😂总之跟苹果也差不多，卖机子不重要，卖拓展坞才重要。整个机子全靠一个百搭的Type-C接口，主要这个Type-C口可以用来充电，这个还是挺好用，只不过一直在家也没试过就是了。 机子的上方是一个关机键和一个音量键（y1s1感觉手感太硬），下方是键盘的磁吸接口，左侧是正规的Surface Pen磁吸处，不过可能因为右侧充电口也有磁吸效果，可以Surface Pen也可以挂上面，只是不如左侧那么牢固。（同理，下方吸键盘的地方也可以吸笔🤪） 机身正面左上方和右上方各一个扬声器模组，上方则是补光灯、前置摄像头和Windows Hello模组，貌似还有几个孔和摄像头，也不知何用，应该都是Windows Hello模组的一部分。 背面则是银色背景，其实我不太明白为啥Go要加那么一个灰色色带，感觉像Surface Pro那样的纯色背面观感更加，背面下半部则是支架以及闪亮的Microsoft Logo（实测可以当镜子🤪）总体的观感还是不错的。机身比我想象中要圆滑一点，四边并不是那么的棱角分明，有明显的弧形设计在（其实我还挺喜欢棱角分明的质感的。。）支架最多可以翻折135°还是165°？多少来着，忘了。反正不管支架张开到什么角度，都可以稳定地支撑住，不会出现架不住瘫下去的情况。 配件 配件也就键盘和笔嘛。 键盘挺薄，但还是有一些分量的。接上机身后可以合拢当屏幕保护盖，也可以直接翻折到背面（这时候键盘断开连接）总体的拆卸安装都挺方便。 笔的话不像Apple Pencil一样那么圆，Surface Pen有一面是平整的，用于吸附在机身上。笔上一个按钮，按住相当于右键的效果，在OneNote中按住则是套索功能。笔的末端是一个按钮，也是橡皮擦，这个橡皮擦功能就非常的实用（然后某天微软大刀部说不定就给砍了🤪）在设置中可以对这个按钮进行快捷键的设定，单击、双击以及长按，对应不同的功能。 Surface Pen使用的是电池供电，而不是充电式的。（一开始见到Apple Pencil插在板子上充电感觉挺新奇也挺方便。但见多了总觉得怪怪的。。。）至于电量确实有保障。我从616到现在吧，断断续续地在用，一个半月时间，现在电量剩余99%。 使用 笔记 首先还是OneNote吧，毕竟购入Surface做笔记自然离不了OneNote，总体来说笔没有很大的延迟，跟手也准的，标尺等功能的使用也方便。压感也体现得很明显（尽管我好像不是很用得到）末端的橡皮擦也很好用，不需要再额外点击对应的功能键。 在OneNote中的橡皮擦是一条一条地擦除，就像PS中的返回上一步操作一般，一次性画成的线条一次行擦除，而不是像“橡皮擦”功能一样，擦到哪儿哪儿就擦除。 OneNote的第一次同步确实有点慢，但当同步完成后就很舒服了，上网课时，笔记本截图贴进去，Surface就能立刻显示出来，Go2上做的笔记画的笔画在笔记本上也能第一时间同步，这个速度确实一开始惊了我一下。 至于说到PDF的话，Microsoft Store还是有些比较方便的应用的，一开始使用的免费的Xodo，以及后来不知为何，突然能白嫖的DrawBoard PDF，平时主要是使用DrawBoard功能更加丰富一些，对Surface Pen的支持也挺好（就是最细的笔触还是有点粗。。） 相对而言Xodo的笔触就细一些，不像Xodo的笔触那么粗，也有一些基本的功能，不知道为什么DrawBoard的橡皮擦反应有点慢。。可能是这个pdf太大了吧。。。大致的使用感觉也还可以，毕竟大部头的系统的笔记还是做在OneNote中。 Xodo的界面更加简洁一点，对Surface Pen的支持也还行，不过还是会有一点延迟。整体功能不如Drawboard PDF，相当于一个是完整版，一个是轻量级，因此启动速度也有差异，一般做记号用Drawboard，单纯浏览用的Xodo。 网页 原本看网上的各种评测说奔腾4425Y性能孱弱，浏览器多开几个标签页就会卡顿，但是对于我这种“只记得开标签，不记得关标签”的使用程度来看，并没有明显的卡顿，总体速度还是很流畅的（使用的旧版自带的Edge浏览器）估计到时候会下一个新版的Edge浏览器以便共通数据啥的，不过暂时还行。 影音 emmmm，虽然不是爱奇艺，但多多少少还是会有用到视频播放。我主要使用的还是Bilibili的UWP应用以及网页播放器，总体感觉完全够用。毕竟也不追剧，追的剧也不是爱奇艺等国产平台上能有的。😓 音乐的话，网易云有UWP应用，平时使用的比较多的也就是网易云音乐，笔记本上用的也是UWP版，更加省电，占用的空间也比较小，轻量但必要功能齐全。近期还更新成了Win32转制版，功能更加丰富了，只是界面不像以前那么简洁了。。多了不少东西。 游戏 不会有人想用Surface Go2打游戏吧？不会吧不会吧？🐕 反正我也只在这机子上看我妈玩过蜘蛛纸牌，无法评价。🤪 耗电 关于耗电一开始还是做过大致测试。从15：00开始，到16：00，期间放着音乐，电量从51%掉到了34%，大概一小时17%的电，也就是大约能连续使用6个小时。在16：00到17：00，期间关闭了音乐，电量从34%掉到了22%，大概一小时12%的电，大约能连续使用8个小时，自然比不上微软官方宣传的时间，但对于一天的课程学习来说，有个午休时间可以充一会儿电，一般情况下还是够用的。充电速度也挺快，大约1-2小时能充满。 最后 对我而言，对于Go2的各方面还是比较满意的，就是毕竟是Win板，对键盘的依赖还是挺大的，虚拟键盘聊胜于无，不像Ipad系列使用舒服。如果有苹果设备那自然是二话不说直接购入Ipad就完事了。 一开始我还是没有退出S模式的，感觉Microsoft Store的应用也大致够用。暂时也不需要退出，毕竟可能S模式更省电🤪但后来为了用Typora和Xmind还是退出了S模式，不过也就下了Typora、Xmind和VsCode三个应用，以后估计也就多一个新版Edge浏览器吧。 17号说的更新计划，到现在发，emmmm，也还行，不算鸽🤪"},{"title":"后网课时期","date":"2020-07-17T11:26:11.000Z","url":"/2020/07/17/%E5%90%8E%E7%BD%91%E8%AF%BE%E6%97%B6%E6%9C%9F/","tags":[["杂谈","/tags/%E6%9D%82%E8%B0%88/"]],"categories":[["杂谈","/categories/%E6%9D%82%E8%B0%88/"]],"content":"距离网课的那段时间已经过了好久，拖延症到现在也不知从何说起。姑且再谈谈大致印象吧。 网课伊始 一开始的网课开始前，我们是满心欢喜的，毕竟没有了地点的拘束，可以睡得更香，有更多的休息时间，在不重要的课上也可以无顾及地做其他的事（当然一开始是“我全都要”的想法）事实也确实如此，但随着时间的流逝，网课的不断过去，一些问题也暴露了出来。慕课的粗糙、老师的失联、讨论的不便（人多话题总是会慢慢歪掉）不可否认的，网课确实给了我们很多的方便，但是学习的效率远不如面授，自控力的不足也加剧了这一情况。 一开始的我还准时准点地守在电脑前，什么课都认真地做着笔记，听着课，而到了后半期的毛概等课则往往是在睡梦中度过，闹铃、进课堂、打卡、继续睡已成了常态。课后的整理知识点的时间也成了游戏时间，效率远不如在校，自然，主要原因是自身的低自控罢了。 网课收官 一开始就在想着买个平板，但在surface go和Ipad之间无法取舍，最后在surface go2 发售后还是选择了入手surface go2，毕竟本身生态和苹果毫无干系而且surface的支架是真的香🤪。总的体验还是不错的，同样的，由于拖延症。。。一直想发的surface go2开箱变成了surface go2体验报告又变成了咕咕咕。 到手的surface go2也算是在网课的最后时期派上了用场，OneNote的第一次同步速度感人，但是一旦同步完成，电脑上截完图surface上也能实时显示，surface上刚写上的笔记在电脑上也能同步显示，确实有点超乎预料。最后的网课部分选择了开卷，部分选择了闭卷，也算是正常发挥吧，难的科目难的题目也都将自己的水准发挥出来了，简单的科目简单的题目也同样憨憨地错了😓 最近也差不多出完了所有的成绩，怎么说呢，绩点学分到达了4.0+，算是两年四学期的最高值了，原以为可以保二等奖争一等奖了，然而一看别的同学的绩点同样跟平时相比有了巨幅上涨，这下可能又悬了。说是别人可能搜题作弊，老师批改不同，实则都是借口，无非是自己还不够优秀罢了，总之有好有坏，有进步的点也有怠惰，以后再继续努力吧。💪 源于课设 这一次的数据库课程设计，由于疫情原因改为线上进行（当然这类课设线不线上一个样），因此小组成员选择了云端的协同开发。因为经常性要对数据库进行更改，一直传到QQ不断下载覆盖明显不太方便，最后是由小组买了一个服务器，把数据库建在了服务器上，这样使用软件通过给定的用户名和密码都可以对数据库进行更新，数据库也能够实时共享，方便了许多。 对于代码的协同开发，对于Github一直有在使用，但又好像没有真正去使用，而这一次也算是有了一次小练手，和一个同学通过Github进行代码的并行开发以及合并，提高了开发课设软件的效率，同时也熟悉了Github和Git的用法。与我而言，相比于课设获得优秀，可能这次使用GIthub协同开发的经历更加重要。当然啦，课设有优秀那就更好了😁（最后也是成功拿到了优秀，尽管中间还是出了点小插曲） y1s1，Java Swing真的还有人用吗。。而且页面是真的丑。用了这些后才觉得CSS是真的厉害，实现的效果优秀多了。不过通过这次数据库课设也对Java的语法有了更深的认识。这时候又要想起博客里那篇咕不动了的Java学习笔记－_－b 暑期兼职 假期开始了，看着同学们一个个都找起了暑期兼职，而自己却还是废人一个待在家里，便不由得心痒痒，在网上找了几个兼职，又不觉得靠谱，犹犹豫豫也没了后话。正当这时，我妈带来了一个私人暑期补习班的兼职，便欣然应允。换我以前肯定是拒绝的，一直想着可不能像以前的小学老师祸害祖国的花朵😑，但可能是因为几天一直在给妹妹补习有了点大概，又或者是对有点零花钱的向往，抑或是同学们都在接触社会给我的压力，感觉像个自闭儿一样。。。。。 总之是开始了暑期的兼职，教三年级的小朋友语数英。（至少是帮我规范了作息时间。😅） 教了几天的感触还是不少的。最明显的就是小孩子的精力确实旺盛。中午的时候在教室上蹿下跳一点倦意都没有，而我却不自觉的眼睛酸痛，想要小咪一会儿。想想自己小时候也是根本闲不下来。现在的我们却往往都是满含倦意，是发生了什么呢？只是单纯的没睡好呢，还是经历的事情多了，承担的事情多了，所以疲惫多了呢？ 以往的我喜欢热闹，讨厌独处。现在的我觉得一人独处也很惬意，有自己的空间，安静、平和，无人打扰。就像以前的我讨厌米饭，喜欢面条等食物，不理解大人为什么唯独喜欢米饭，而现在的我在有面有粉条有年糕的情况下却还是青睐于米饭。至于为什么，我也不知道。 关于博客 现在看看，博客的上一次更新已经是5月10日，两个月过去了，虽说有期末、课设的因素在，但确实太鸽了。想法有不少，行动却不多。就像我的surface go2开箱，有始无终。其实也有在想到底要在博客放些什么，一开始想的是先做成笔记本，于是把一些课程的知识点整理起来发在博客上，但后来发现太耗时了，而且意义不太大，这些文章有在看，但看的并不多。再者现在有了surface，估计笔记类还是放在OneNote和Bamboo Paper这种笔记软件上更好一点。 那博客放什么呢。？估计可能还是一些零零碎碎的小东西吧，供自己可以随时查阅。至少应该不会有像XX课YY内容这种的了😂 更新计划 ✔️《后网课时期》综述 ✔️ surface go2使用报告 …"},{"title":"Failed to connect to github.com port 443: Timed out","date":"2020-07-09T14:00:25.341Z","url":"/2020/07/09/error%20src%20refspec%20Cardy%20does%20not%20match%20any./","tags":[["problems","/tags/problems/"],["git","/tags/git/"]],"categories":[["problems","/categories/problems/"]],"content":"$ git push origin Cardy error: src refspec Cardy does not match any. error: failed to push some refs to ‘git@github.com:GoatYoung/DormManager.git’ 出现问题 在git的本地分支尝试向github推代码时出现了下述错误： 出错代码： 报错信息： 出现问题的原因 本地库对应的分支是master，而尝试推的云端分支是Cardy，两个分支不一致，所以出现报错 解决办法 将代码改成： 即：将本地库的master分支推到云端的Cardy分支上。"},{"title":"Fluid添加暗黑模式","date":"2020-05-10T06:54:32.000Z","url":"/2020/05/10/Fluid%E6%B7%BB%E5%8A%A0%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/","tags":[["hexo 美化","/tags/hexo-%E7%BE%8E%E5%8C%96/"]],"categories":[["博客美化","/categories/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"]],"content":"为Fluid添加暗色模式 之前一直就想为博客添加个暗色模式，但是拖延症晚期😿，所以一直拖到了现在，主要的代码参考自Royce的博客，emmm，这里还是把代码搬一下。。 HTML 首先是HTML，在\\themes\\fluid\\layout\\layout.ejs中找到&lt;body&gt;标签，然后在下方加入以下代码 这里原本是用了媒体查询的，可以根据浏览器是否开启深色模式来对应开启深色模式，不过貌似有点小问题😓，比如我的浏览器开了深色模式，但我点击了按钮，切换成了亮色模式，那肯定是说明我是喜欢以亮色模式访问该网站，但当我换了一个页面的时候（比如换了一个文章或回到首页）它又会检测到深色模式后切换到深色模式，emmmm，所以就先删了。。 JS 然后是JS，在主题下的source\\js文件夹下新建一个 DarkMode.js 文件，在其中加入以下代码 然后在Fluid主题的_config.yml中找到custom_js项，加入新建的 js 文件。 这个原版代码是通过注释中的两个字符——“🌞“和“🌙”来进行区分暗色模式和亮色模式。但个人觉得不太美观，同样，他的博客中也有一篇提到了 “返回页面顶”的一个类似于小挂件的效果，于是就想将那个挂件的效果改为更改模式，因此用PS粗粗地P了两个图，分别是带月亮dark.png和带太阳的light.png，在该段JS代码中，在切换模式的同时，将两个图片进行了切换。 CSS 最后是CSS，在主题下的source\\css文件夹下，新建一个DarkMode.styl因为使用的是 style 文件，所以可以不在 _config.yml中引入，直接在同目录下的main.styl中进行导入即可。添加以下代码。 对于原版CSS中的配色方案进行了微调，同时在CSS中添加了切换按钮的点击效果，原本是点击图片直接切换模式和图片，但感觉略显生硬，因此为它添加了一点小效果，就像是旧式的拉绳式的电灯，当按下时，“绳子变长”，即图片下移一部分，当鼠标松开时再回到原位，并更换图片。 将原版HTML中的&lt;div&gt;标签改为&lt;a&gt;标签，这样便可以通过:active来响应鼠标按下事件，只需要在鼠标按下时将图片下移即可。即在style文件最后添加 原本想着是不是要用贝塞尔曲线来加个动画来着。。。后来发现根本也不会按那么久。单单点击只要让图片下移就可以有差不多的效果了。🙈 light图片 "},{"title":"DRAM三种刷新方式","date":"2020-04-16T04:24:35.000Z","url":"/2020/04/16/DRAM%E4%B8%89%E7%A7%8D%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"DRAM的三种刷新方式：集中刷新、分散刷新、异步刷新。 电路中的C1和C2用于保持数据，但因为电容C1和C2保持电荷很小，所以能维持稳定的时间也很短，因此要进行刷新操作来对C1和C2充电 刷新与行地址有关。 刷新时一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本单元电路的逐行刷新，才能保证DRAM内的信息不丢失。 有三种刷新方式：集中刷新、分散刷新、异步刷新。 假定: 刷新周期为2ms 存取周期为0.5μs，即刷新一行的时间是0.5μs 对128 x 128的矩阵的存储芯片进行刷新，按存储单元（1B/单元）分为128行和128列，即128 * 128 * 1B/单元=214个单元 * 1B/单元 = 16KB内存。 例如16k x 8的芯片就是128行 * 128列 集中刷新 集中刷新是在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。 所需的时间为0.5μs * 128 = 64μs，在这64μs的时间内对128行逐行进行刷新，在这期间不能进行读/写操作，称为“死时间”。 在2ms内有2000 / 0.5 = 4000个读写周期，其中128个读写周期用来刷新，所以平均读写周期为 2ms/（4000-128） = 0.5165μs 分散刷新 分散刷新是指对每行存储单元的刷新分散到每个存取周期中，即每次存取之后对该行数据进行一次刷新，相对于一个存取周期内对该行数据进行两次访问，因此延长了存取周期，平均读写周期为1μs，前半段用来存取，后半段用来刷新。这样每有128个读取操作，就会把0-127行全部刷新一遍，刷新周期为1μs * 128 = 128μs（即过128μs，数据全部刷新了一次） 这样做虽然解决了“死时间”的问题，但刷新过于频繁，影响性能。 异步刷新 异步刷新既可以缩短“死时间”，又可以充分利用最大刷新间隔为2ms的特点，不过于频繁地刷新从而影响性能，那就可以把128行的刷新步骤平均分配到这2ms中，即每隔15.6μs刷新一行（2000μs / 128 ≈ 15.6μs），而每行的刷新时间仍为0.5μs，这样刷新间隔为2ms，死时间为0.5μs。可以理解为把2ms分成128段，每段15.6μs，在每段分别执行集中刷新。 参考：CSDN博客-DRAM的三种刷新方式的刷新周期问题"},{"title":"第三章：运算方法","date":"2020-04-10T09:04:29.000Z","url":"/2020/04/10/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"一些运算方法，包括定点数加减法、原码一位乘法、补码一位乘法、原码除法、浮点数加减法等 定点数加减法运算 定点数加法 定义：[X+Y]补 = [X]补 + [Y]补 【例1】 已知X = +10010 Y = -10101，求X+Y 解： [X]补 = 010010 [Y]补 = 101011 [X+Y]补 = [X]补 + [Y]补 = 010010 + 101011 = 111101 所以[X+Y]原 = 100011 所以X+Y = -00011 定点数减法 定义：[X-Y]补 = [X]补 - [Y]补 = [X]补 + [-Y]补 【例2】 已知X = + 10110 Y = + 10011 解： [X]补 = 010110 [Y]补 = 010011 [-Y]补 = 101101 [X-Y]补 = [X]补 + [-Y]补 = 010110 + 101101 = 000011 所以[X-Y]原 = 000011 X-Y = + 00011 溢出检测方法 溢出只可能发生在同符号数相加时，例如[X]补与[Y]补；[X]补与[-Y]补同号 方法1：对操作数和运算结果的符号位进行检测 当结果的符号位与操作数的符号位不相同时就表名发生了溢出 设X0，Y0为运算数的符号，S0为结果的符号位 V=X0Y0S0‾+X0‾Y0‾S0V=X_0Y_0\\overline{S_0} + \\overline{X_0}\\overline{Y_0}S_0V=X0​Y0​S0​​+X0​​Y0​​S0​ 当V=1时，运算结果溢出。 例如： [X]原 = 0100100 [Y]原 = 0111100 则[X]补 = 0100100 [Y]补 = 0111100 [X+Y]补 = [X]补 + [Y]补 = 0100100 + 0111100 = 1100000 可以发现，两个正数相加，却得到了一个负数，显然是错误的，根据公式 V=001‾+0‾0‾1=1V=00\\overline{1} + \\overline{0}\\overline{0}1 = 1V=001+001=1说明溢出 方法2：对最高数据位进位和符号进位进行检测 设运算时最高数据位产生的进位为C1，符号位产生的进位为C0 溢出检测电路为：V=C0⊕C1V = C_0 \\oplus C_1V=C0​⊕C1​ 同样，V=1时说明溢出 可以这么理解： 当最高数据位进位为0，符号位进位为0，说明最高位相加没有进位，符号位也没有进位，则符号位不变，所以数据没有溢出 当最高数据位进位为1，符号位进位为1，说明最高位相加得到一个进位，符号位相加也得到了一个进位，所以最后保留的符号位还是原来的符号位 例如：1100+1101 = 11001，多余的符号位去除，剩下最右侧的符号位1，得到1001，用原码表示即为1111 = -7，运算数用原码表示为-4+(-3)，-4-3=-7，正确，说明没有溢出 当最高数据位进位为1，符号位进位为0，说明最高位进了一位，而符号位却没有进位，说明符号位由0变成了1，符号位发生了变化，发生溢出 当最高数据位进位为0，符号位进位为1，说明最高位没有进位，但符号位却进位了，说明符号位由1变成了0，发生了变化，发生溢出 方法3：用变型补码（即两位符号位） 溢出判断为V=Xf1⊕Xf2V = X_{f1} \\oplus X_{f2}V=Xf1​⊕Xf2​ 两个数分别为两个符号位 例如初始值是负数就是11，正数就是00，当溢出时会有进位到符号位，使两个符号位不一致，变为10或01，则说明发生了溢出 例如： 已知X = -10010 ，Y = -10101， 求X+Y 则[X]补 = 1110010， 1110101 [X+Y]补 = [X]补 + [Y]补 = 1101110 + 1110101 = 11010001，去掉多余的符号位，得到符号位10，两个符号位不一致，说明溢出。 用原码表示即-18-23=-41，而五位二进制表示最大为-31，溢出 原码一位乘法 移位操作[1] 采用二进制乘法，分成部分积和乘数/判断位两部分，X为被乘数，Y为乘数，根据Y的最后一位来决定部分积加的内容，若Y最后一位为1，则部分积+|X|，若Y的最后一位为0，则部分积+0，每做完一次加法，进行一次右移操作，右移移出的数加到乘数第一位。 数值部分取绝对值参加运算，符号位单独运算，采用双符号位 小数点后有n位，就进行n次加法运算和n次移位操作 补码一位乘法 设[X]补 = X0X1X2X3…Xn [Y]补 = Y0Y1Y2Y3…Yn 补码一位乘法运算规则如下： 如果Yn+1 = Yn，则部分积+0，部分积算术右移一位 如果Yn+1&lt; Yn，即 YnYn+1= 10，部分积+[-X]补，部分积算术右移一位 如果Yn+1 &gt; Yn，即YnYn+1 = 01，部分积+[X]补，部分积算术右移一位 重复进行n+1步，但最后一步不移位 符号位参与运算，采用双符号位，没有Yn+1位，所以在Y末位补0，当做初始Yn+1位 补码有n位数（单符号位，包括符号），就进行n次加法运算，n-1次移位运算 定点数除法（原码一位除法） 手工除法 恢复余数法 已经除法通过减法来实现，那么通过采用双符号位可以得到余数的符号的变化 若余数为正数，说明够减，那么商上1，将余数左移一位，再作为被减数 若余数为负数，说明不够减，即被减数小于减数，那么商上0，得到的余数再加上减数，即可恢复到被减之前，然后再左移一位，作为新的被减数 重复上述步骤直到商达到所需的位数 最后结果=符号位异或+商 余数R=余数 * 2-n （n为左移次数） 示例： 设X=0.1001，Y=-0.1011，用原码一位除法求X/Y 解： [X]原 = 0.1001 [|X|]补 = 0.1001 [Y]原 = 1.1011 [|Y|]补 = 0.1011 [-|Y|]补 = 1.0101 不恢复余数法 设某次余数为Ri，将Ri左移一位减除数，对得到余数进行判断并上商，即： 2Ri - Y 在恢复余数法中，当上述结果小于0时，商上0，再加上除数来恢复余数，之后再左移一位后再与除数比较，即： （2Ri - Y）+ Y=2Ri 2 * 2Ri - Y = 4Ri - Y 当如果我们不恢复余数，当结果小于0时，上商0后直接将余数左移一位，再加上Y，即： 2（2Ri - Y） + Y = 2 * 2Ri - 2Y + Y = 4Ri - Y 可以看到两者是等价的，那么我们便可以不进行恢复余数操作，直接将余数左移后+Y 最后结果跟恢复余数法一致： 最后结果=符号位异或+商 余数R=余数 * 2-n （n为左移次数） 示例： 已知，X = 0.1001，Y = -0.1011，用原码一位除法求X/Y 解： [X]原 = 0.1001 [|X|]补 = 0.1001 [Y]原 = 1.1011 [|Y|]补 = 0.1011 [-|Y|]补 = 1.0101 浮点数加减法 首先讲一下浮点数的规格化方法 规格化浮点数的正数形式为：0.1xxxxx，负数形式为：1.0xxxxx 那么当尾数结果为 00.0xxxx或 11.1xxxx时，需要进行左规，将尾数左移，每移动一次，阶码减1，直到尾数形式为00.1xxxx或11.0xxxx，因为如果右移的话，因为是添加的值复制左侧符号位，所以00.0xxxx无论怎么右移都是00.0xxxx，11.1xxxx无论怎么右移都是11.1xxxx 当尾数的结果为 01.xxxxx或10.xxxxx时，表明尾数求和的结果&gt;1，这时候只需要执行一次右移规格化，每右移一次，阶码加1，即变为00.1xxxx和11.0xxxx 浮点数加减运算的三个步骤： 对阶，即先使两个数的阶码相等 尾数求和 规格化 1. 对阶 设浮点数为 x=Sx⋅2jxx=S_x \\cdot 2^{j_x}x=Sx​⋅2jx​ y=Sy⋅2jyy=S_y \\cdot 2^{j_y}y=Sy​⋅2jy​ 求阶差 Δj=jx−jy={=0,jx=jy已对齐&gt;0,jx&gt;jyy向x看齐，Sy每左移一位，jy加一&lt;0,jx&lt;jyx向y看齐，Sx每左移一位，jx加一 \\Delta j = j_x - j_y =\\left\\{ \\begin{aligned} = 0 &amp;, j_x = j_y &amp; 已对齐 \\\\ {&gt; 0} &amp;, j_x &gt; j_y &amp; y向x看齐，S_y每左移一位，j_y加一 \\\\ {&lt; 0 } &amp;, j_x &lt; j_y &amp; x向y看齐，S_x每左移一位，j_x加一 \\\\ \\end{aligned} \\right. Δj=jx​−jy​=⎩⎪⎨⎪⎧​=0&gt;0&lt;0​,jx​=jy​,jx​&gt;jy​,jx​&lt;jy​​已对齐y向x看齐，Sy​每左移一位，jy​加一x向y看齐，Sx​每左移一位，jx​加一​ 当两者的阶码相等时，说明已经完成对阶，可以直接进行尾数求和，如果不相等，那么阶码小的向阶码大的看齐 因为阶码变大，说明尾数右移，最后几位数值会被丢失，但因为最后几位的数值在真值中很小，所以对数值变化影响不大，但阶码变小，说明尾数右移，最高的几位会被丢失，这最高的几位在真值中的数值很大，因此损失这几位会导致较大的数据变化，因此一律选择阶码小的向阶码看齐。 例如： 1.0110 * 25左移两位变为1.1000 * 23，右移两位变为 1.0001 * 27 1.0110 * 25 = -12 1.1000 * 23 = -4 1.0001 * 27 = -8 显然右移对数值的变化更小 对阶 得到两者的阶差n后，阶码比较小的数的尾数右规n位，阶码+n，得到新的值 2.尾数求和 在对完阶后，将两者的尾部部分的补码进行相加 3.规格化 对得到的加数进行规格化 【示例1：】 x = 0.1101 * 201 y = (-0.1010) * 211，求x+y 解： [x]补 = 00,01（阶码部分）; 00.1101（尾数部分） [y]补 = 00,11 ; 11.0110 ①对阶 Δj=jx−jy=00,01+11,01=11,10\\Delta j = j_x - j_y = 00,01 + 11,01 = 11,10Δj=jx​−jy​=00,01+11,01=11,10 得到阶差为 -2，即jx &lt; jy，所以x的尾数右移两位，阶码+2 得到x为00,11 ；00.0011 ②尾数求和 00.0011 + 11.0110 --------------------- 11.1001 所以[x+y]补 = 00,11 ；11.1001 [x+y]原 = 00,11 ；11.0111 【示例2：】 x = 0.1101 * 210 y = 0.1011 * 201，求x+y 解： [x]补 = 00,10 ；00.1101 [y]补 = 00.01 ；00.1011 ①对阶 Δj=jx−jy=00,10+11,11=00,01\\Delta j = j_x - j_y = 00,10 + 11,11 = 00,01Δj=jx​−jy​=00,10+11,11=00,01 得到阶差为 +1，即jx &gt; jy，所以y的尾数右移一位，阶码+2 得到x为00,10 ；00.0101 ②尾数求和 00.1101 + 00.0101 --------------------- 01.0010 ③规格化 得到的结果为00,10 ； 01.0010 需要右规一位，得到结果：00,11 ；00.1001 所以[x+y]原 = [x+y]补 = 0.1001 * 211 逻辑左移：数据整体左移一位，最高位移出，最低位补0 算术左移：数据整体左移一位，最高位移出，最低位补0，相当于乘2 逻辑右移：数据整体右移一位，最低位移出，最高位补0 算术右移：除符号位外数据整体右移一位，最低位移出，符号位复制一份补到最高位 ↩︎ "},{"title":"数据库系统原理：第三章关系数据库语言（二）","date":"2020-04-02T06:58:46.000Z","url":"/2020/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%EF%BC%88%E4%BA%8C%EF%BC%89/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["数据库系统原理","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"categories":[["数据库系统原理","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"content":"关于数据查询的知识点。 数据查询 选择查询 格式： SELECT [ ALL | DISTINCT ] &lt;目标列表达式&gt;，&lt;目标列表达式&gt; … FROM &lt;表名或视图名&gt;, &lt;表名或视图名&gt; … WHERE &lt;条件表达式&gt; GROUP BY &lt;列名&gt; HAVING &lt;条件表达式&gt; ORDER BY &lt; ASC | DESC &gt; SELECT：指定要显示的属性列，相当于“投影”操作 FROM：指定查询对象 WHERE：指定查询条件 GROUP BY：对查询结果按指定列的值分组，该列中属性值相等的元组并为一个组，即去除重复值 HAVING：在有GROUP BY的情况下才能使用，等效于WHERE，但WHERE中无法使用“MAX”之类的聚集函数，HAVING中可以 ORDER BY：对查询结果按指定列值的升序或降序排序 若WHERE和HAVING同时存在，先执行WHERE，对WHERE得到的值进行GROUP BY分组，再根绝HAVING 条件进行筛选 ALL：选择所有值 DISTINCT：去掉所有重复值 SELECT 【例1】查询全体学生的学号与姓名 【例2】查询全体学生的详细记录（全部信息） 全部信息用*代替 SELECT子句的&lt;目标列表达式&gt;还可以是表达式 【例3】查询全体学生的姓名及其出生年份 WHERE 常用的查询条件 查询条件 谓词 比较 =, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;; NOT + 上述比较运算符 确定范围 BETWEEN AND, NOT BETWEEN AND 确定集合 IN，NOT IN 字符匹配 LIKE, NOT LIKE 空值 IS NULL, IS NOT NULL 多重条件 AND, OR, NOT 比较 【例4】查询计算机科学系全体学生的名单 【例5】查询所有年龄在20岁以下的学生姓名及其年龄 【例6】查询考试成绩有不及格的学生的学号 确定范围 【例7】查询年龄在20-23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄 确定集合 【例8】查询计算机科学系CS、数学系MA和信息系IS学生的姓名和性别 字符匹配 格式： [ NOT ] LIKE ‘&lt;匹配字符串&gt;’ [ ESCAPE ‘&lt;转义字符&gt;’] 匹配字符串：可以是完整字符串也可以是带有通配符%和_的字符串 %：代表任意长度（也可以是0）的字符串 _：代表单个字符 ESCAPE：之后的字符作为转义字符 例如ESCAPE '\\'就说明'\\'用作转义字符 【例9】查询所有姓刘学生的姓名、学号和性别 【例10】查询以“DB_”开头，且倒数第3个字符为i的课程的详细信息 涉及空值的查询 【例11】查询缺少成绩的学生的学号和相应的课程号 其中 “IS” 不能用 “=” 代替 多重条件查询 AND的优先级高于OR 可以用括号改变优先级 ORDER BY子句 可以按一个或多个属性列排序 【例12】查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列 聚集函数 统计元组个数 COUNT(*) 统计一列中值得个数 COUNT( [ DISTINCT | ALL ] &lt;列名&gt; ) DISTINCT说明统计得是不同得值 计算一列值得总和（数据类型必须为数值型） SUM( [ DISTINCT | ALL ] &lt;列名&gt; ) 计算一列值得平均值（数据类型必须为数值型） AVG( [ DISTINCT | ALL ] &lt;列名&gt; ) 求一列中的最大值和最小值 MAX( [ DISTINCT | ALL ] &lt;列名&gt; ) MIN( [ DISTINCT | ALL ] &lt;列名&gt; ) 【例13】查询学生总人数 【例14】查询选修了课程的学生人数 【例15】计算1号课程的学生平均成绩 【例16】查询学生201215012选修课程的总学分数 GROUP BY 细化聚集函数的作用对象 如果未对查询结果分组，聚集函数将作用于整个查询结果 对查询结果分组后，聚集函数将分别作用于每个组 按指定的一列或多列值分组，值相等的为一组 【例17】求各个课程号及相应的选课人数 那么输出结果可能为: Cno COUNT(Sno) 1 22 2 34 3 44 4 33 5 15 连接查询 一般格式： &lt;表名1&gt;.&lt;列名1&gt; 比较运算符 &lt;表名2&gt;.&lt;列名2&gt; 等值与非等值连接查询（自然连接） 自然连接 【例18】查询选修2号课程且成绩在90分以上的所有学生的学号和姓名 自身连接 因为是自身与自身连接，所以所有的属性名都是同名属性，因此必须使用别名前缀进行区分。 【例19】查询每一门课的直接先修课的名称 外连接 通过外连接来实现“连接”操作中的悬浮元组 左外连接 列出左边关系中的所有元组，即保留左侧悬浮元组 右外连接 列出右边关系中的所有元组，即保留右侧悬浮元组 【例20】 多表连接 即使用多个自然连接 【例21】查询每个学生的学号、姓名、选修的课程名及成绩 嵌套查询 查询块：一个SELECT-FROM—WHERE 语句 嵌套查询：一个查询块嵌套在另一个查询块的WHERE子句或HAVING子句中 外层查询/父查询：上层/外层的查询块 内层查询/子查询：下层/内层的查询块 分类 不相关查询：子查询的查询条件不依赖于夫查询 由里向外逐层处理。即每个子查询可以独立完成查询，子查询的结果用于建立其父查询的查找条件 执行过程： （1）执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。 （2）执行外部查询，并显示整个结果 相关查询：子查询的查询条件依赖于父查询 子查询不能独立完成查询，多数情况下是子查询的WHERE子句中引用了外部查询的表。 执行过程： （1）从外层查询中取出一个元组，将元组相关列的值传给内层查询。 （2）执行内层查询，得到子查询操作的值。 （3）外查询根据子查询返回的结果或结果集得到满足条件的行。 （4）然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。 【示例】查询Booka表中大于该类图书价格平均值的图书信息 这里的子查询中用到了父查询的表a，所以依赖于父查询中的数据，不能独立执行 参考自  带有IN谓词的子查询 【例22】查询选修了课程名为“信息系统”的学生学号和姓名 带有比较运算符的子查询 【例23】找出每个学生超过他选修课程平均成绩的课程号 带有ANY（SOME）或ALL谓词的子查询 ANY——存在量词 ALL——全称量词 使用ANY或ALL谓词时必须同时使用比较运算，例如 &gt; ANY 大于子查询结果中的某个值 &gt; ALL 大于子查询结果中的所有值 … 【例24】查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄 ANY,ALL谓词与聚集函数、IN谓词的等价转换关系 = &lt;&gt;、!= &lt; &lt;= &gt; &gt;= ANY IN \\ &lt;MAX &lt;=MAX &gt; MIN &gt;=MIN ALL \\ NOT IN &lt;MIN &lt;=MIN &gt;MAX &gt;=MAX 带有EXISTS谓词的子查询 带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false” 若内层查询结果非空，则外层的WHERE子句返回真值 若内层查询结果为空，则外层的WHERE子句返回假值 由EXISTS引出的子查询，其目标列表达式通常都用*，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义。 【例25】查询所有选修了1号课程的学生姓名 上述代码执行思路： 从Student中提取第一个元组，带入子查询中，若结果不为空，则返回真值，说明该学生选修了1号课程，输出，再读取下一个值。 用EXISTS实现全称量词 EXISTS表示存在，任意全称量词都可以转换成等价的带有存在量词的谓词： （∀x）P≡¬（∃x（¬p））（\\forall x）P \\equiv \\lnot（\\exists x （\\lnot p））（∀x）P≡¬（∃x（¬p）） 用EXISTS实现逻辑蕴含 p→q≡¬p⋁qp \\to q \\equiv \\lnot p \\bigvee qp→q≡¬p⋁q 【例26】查询所有选修了学生201215122选修的所有课程的学生的学号 p：学生201215122选了课程y q：学生x选了课程y 那么就是只要学生201215122选了，学生x就也选修了该门课 得到逻辑关系为(∀y)p→q(\\forall y)p \\to q(∀y)p→q 对逻辑关系进行等价变换： (∀y)p→q≡¬(∃y(¬(p→q)))(\\forall y) p \\to q \\equiv \\lnot (\\exists y (\\lnot ( p \\to q)))(∀y)p→q≡¬(∃y(¬(p→q))) ≡¬(∃y(¬(¬p⋁q)))\\equiv \\lnot (\\exists y (\\lnot (\\lnot p \\bigvee q)))≡¬(∃y(¬(¬p⋁q))) ≡¬∃y(p⋀¬q)\\equiv \\lnot \\exists y (p \\bigwedge \\lnot q)≡¬∃y(p⋀¬q) 得到可以用EXISTS表示的式子，语义为不存在这样的课程y，学生201215122选修了，而学生x没有选 "},{"title":"数据库系统原理：第三章关系数据库语言（一）","date":"2020-03-29T08:29:40.000Z","url":"/2020/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["数据库系统原理","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"categories":[["数据库系统原理","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"content":"数据库系统原理第三章的部分内容，主要包括SQL概述和数据定义。 SQL概述 SQL的特点 综合统一 集数据定义语言（DDL）、数据操纵语言（DML）、数据控制语言（DCL）于一体 DDL：Create（创建）、Alter（修改）、Drop（删除） DML：Insert、 Delete、Update、Select DCL：Grant、 Revoke 高度非过程化 面向集合的操作方式 以同一种语法结构提供多种使用方式 SQL是一种独立的语言 SQL又是一种嵌入式语言，可以嵌入到C++、Java等高级语言中使用 语言简洁，易学易用 SQL功能 动词 数据查询 SELECT 数据定义 CREATE、DROP、ALTER 数据操纵 INSERT、UPDATE、DELETE 数据控制 GRANT SQL的基本概念 SQL支持关系数据库的三级模式结构 基本表 本身独立存在的表。存储在数据库中，所以基本表是实表。 视图 从一个或几个基本表导出的表。不独立存储在数据库中，数据库中只存储视图的定义，不存储视图的数据，视图的数据来源于基本表，所以视图是虚表。 用户可以在视图上再定义新的视图。 存储文件、索引 表中数据和相应存储位置的列表。建立索引可以加快查询速度。索引存放在存储文件中，属于内模式的范畴。 数据定义 数据定义语句 th, td{ text-align:center; } 操作对象 操作方式 创建 删除 修改 模式 CREATE SCHEMA DROP SCHEMA 模式无法修改 表 CREATE TABLE DROP TABLE ALTER TABLE 视图 CREATE VIEW DROP VIEW 视图无法修改 索引 CREATE INDEX DROP INDEX ALTER INDEX 模式 下文出现的尖括号和方括号均可忽略 模式定义 定义模式实际上定义了一个命名空间（或者说目录） 在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。 在CREATE SCHEMA 中可以接受 CREATE TABLE，CREATE VIEW 和 GRANT子句 格式如下 CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [ &lt;表定义子句&gt; | &lt;视图定义子句&gt; | &lt;授权定义子句&gt; ] 示例： 【例1】为用户WANG定义一个学生-课程模式S-T CREATE SCHEMA “S-T” AUTHORIZATION WANG; 【例2】若没有指定模式名，则默认为用户名 CREATE SCHEMA AUTHORIZATION WANG; 删除模式 格式： DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt; CASCADE（级联） 删除模式的同时把该模式中所有数据库对象全部删除 RESTRICT（限制） 如果该模式中定义了下属的数据库对象，即不为空，则无法删除 基本表 定义基本表 格式： CREATE TABLE &lt;表名&gt; ( &lt;列名&gt; &lt;数据类型&gt; [ &lt;列级完整性约束条件&gt; ], &lt;列名&gt; &lt;数据类型&gt; [ &lt;列级完整性约束条件&gt; ], …, &lt;表级完整性约束条件&gt;); 表名：所要定义的基本表的名字 列名：组成该表的各个属性（列） 列级完整性约束条件：涉及相应属性列的完整性约束条件 表级完整性约束条件：涉及一个或多个属性列的完整性约束条件 常用的完整性约束： NULL/not null： 表示属性列不能为空 primary key（A）： 表示属性列A构成关系的主码 foreign key（A） reference r： 表示属性列A构成关系的外码，且被参照关系为r check（P）： 表示关系中的每个元组必须满足谓词P unique（A）： 表示每个元组在属性列A上是唯一的，即没有重复值 【例3】建立“学生”表STUDENT，学号是主码，姓名取值唯一 【例4】建立一个“课程”表Course 【例5】建立一个学生选课表SC 修改基本表 ALTER TABLE &lt;表名&gt; [ ADD &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ]] [ ADD &lt;表级完整性约束&gt; ] [ DROP &lt;列名&gt; [ CASCADE|RESTRICT ]] [ DROP &lt;完整性约束条件&gt; ] [ ALTER &lt;列名&gt; &lt;数据类型&gt;]; 表名：要修改的基本表 ADD子句：增加新列和新的完整性约束条件 DROP子句：删除指定列和完整性约束条件 ALTER子句：修改数据类型等 【例6】向Student表增加“入学时间”列，其数据类型为日期型 ALTER TABLE Student ADD S_entrance DATE 不管基本表中原来是否已有数据，新增加的列一律为空值。 【例7】将年龄的数据类型（设原类型是字符型）改为整数型 ALTER TABLE Student ALter COLUMN Sage INT 【例8】增加课程名称必须取唯一值的约束条件 ALTER TABLE Course ADD UNIQUE(Cname) 删除基本表 格式： DROP TABLE &lt;表名&gt; [RESTRICT | CASCADE]; RESTRICT：删除表是有限制的，如果存在依赖该表的对象，则此表不能被删除 CASCADE：删除该表没有限制，在删除基本表的同时，相关的依赖对象一起删除 索引 索引的定义 索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构。是某个表中一列或一些列的值和指向这些数据的指针列表组成的清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。 建立索引 格式： CREATE [UNIQUE | CLUSTERED | NONCLUSTERED] INDEX &lt;索引名&gt; ON &lt;表名&gt; ( &lt;列名&gt; 次序 ，&lt;列名&gt; 次序 … ) 表名：要建立索引的基本表的名字 索引可以建立在该表的一列或多列上，各列名之间用逗号隔开 次序：指定索引值的排列次序，升序：ASC，降序：DESC，缺省值为ASC UNIQUE：此索引的每一个索引值只对应唯一的数据记录[1] CLUSTERED：表示要建立的索引是 聚簇索引 NONCLUSTERED：表示要建立的索引是非聚簇索引 聚簇索引要求数据库文件的物理顺序和索引排列顺序一致，而非聚簇索引则不做要求，数据库文件的物理顺序和索引排列顺序可以不同 【例9】为学生-课程数据库中的Student,Course,SC三个表建立索引，Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引。 CREATE UNIQUE INDEX Stusno ON Student(Sno); CREATE UNIQUE INDEX Coucno ON Course(Cno); CREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC); 修改索引 格式： ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;; 【例10】将SC表的SCno索引名改为SCSno ALTER INDEX SCno RENAME TO SCSno; 删除索引 格式： DROP INDEX &lt;索引名&gt;; 在删除索引时，系统会从数据字典中删去有关该索引的描述。 【例11】删除Student表的Studsname索引 DROP INDEX Stusname; 唯一索引是不允许其中任何两行具有相同索引值的索引。 ↩︎ "},{"title":"数字电路基础：触发器","date":"2020-03-28T08:29:25.000Z","url":"/2020/03/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%EF%BC%9A%E8%A7%A6%E5%8F%91%E5%99%A8/","tags":[["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"],["数电","/tags/%E6%95%B0%E7%94%B5/"],["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[["数电基础","/categories/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/"]],"content":"各种触发器的相关内容 一、概念 基本结构 有两个互补的输出端QQQ和Q‾\\overline{Q}Q​ 有两个稳定状态“1”和“0” “1”状态：Q=1Q=1Q=1 Q‾=0\\overline{Q}=0Q​=0 “0”状态：Q=0Q=0Q=0 Q‾=1\\overline{Q}=1Q​=1 当输入信号不发生变化时，触发器状态确定不变，即保持上一状态。 触发器状态 现态 输入信号作用前的状态，记作QnQ^nQn和Qn‾\\overline{Q^n}Qn​ 一般简记为QQQ和Q‾\\overline{Q}Q​ 次态 输入信号作用后的状态，记作Qn+1Q^{n+1}Qn+1和Qn+1‾\\overline{Q^{n+1}}Qn+1​ 二、基本R-S触发器 与非门R-S触发器 亦称为直接复位置位触发器 是构成各种功能触发器的基本部件 R：置0端或者复位端 S：置1端或者置位端 基本工作原理： 所以当RS=11时，Qn+1=Q，即保持原来状态不变 所以当RS=10时，Qn+1=0，置0 所以当RS=01时，Qn+1=1，置1 所以当RS=00时，不存在互补输出端，所以不允许这种输入 与非门R-S触发器状态描述 d表示不定，即可为1，可为0 当与非门构成的基本R-S触发器的同一输入端连续出现多个负脉冲信号时，仅第一个使触发器状态发生改变，因为00不使用，11保持上一状态。 或非门R-S触发器 跟与非门的R-S触发器相反，或非门的R-S触发器，00为保持位，10为置1，01为置0，11不使用 或非门R-S触发器状态描述 两者对比 R和S的位置互换了，因为R是置0端，S是置1端。要符合这种说法的话，在或非门里R和S需要互换位置 只有当R和S为低电平的时候才会对与非门的输出进行改变，所以称为低电平有效，输入端取反 只有当R和S为高电平的时候才会对或非门的输出进行改变，所以称为高电平有效，输入端不变 三、时钟控制触发器 钟控R-S触发器 当时钟信号CP为0时，R’和S’始终为1，即始终保持上一状态 当时钟信号CP为1时，R’和S’为R和S取反，功能跟或非门R-S触发器一样 钟控D触发器 钟控J-K触发器 是J-K不是JK😒 钟控T触发器 即把J-K触发器的J-K用一个T代替 时序逻辑电路概述 当CP=0时，触发器保持状态不变 当CP=1时，触发器在输入信号作用下发生状态变化 触发器的状态转移被控制在一个约定的时间间隔内，而不是控制在某一时刻 只有当CP=1时，输入信号的变化才有意义，才会影响输出 四、维持阻塞触发器 空翻现象 当输入信号在短时间内发生多次变化时，会导致输出端的信号也发生多次变化 空翻现象的原因 时钟脉冲作用期间，输入信号直接控制着触发器状态的变化，当输入信号变化，输出信号随之变化 时钟宽度控制不够，即CP为1的时间过长，使输入端的多次变化得到完全响应。 为解决空翻现象，出现了维持阻塞触发器 边沿触发器概念 仅在时钟脉冲的上升沿或下降沿时刻进行采样并确定触发器的状态。 如上图所示，在绿色爆炸图案处，输入端D在一个时钟周期内发生了两次置1，但不在时钟信号的上升沿或下降沿，因此不做处理，因此避免了空翻现象。 "},{"title":"数字电路基础","date":"2020-03-28T06:33:25.000Z","url":"/2020/03/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/","tags":[["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"],["数电","/tags/%E6%95%B0%E7%94%B5/"],["学习","/tags/%E5%AD%A6%E4%B9%A0/"]],"categories":[["数电基础","/categories/%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/"]],"content":"主要包含了数字电路概念、逻辑代数、基本公理、复合逻辑、集成门电路以及正负逻辑的相关内容。 一、数字信号及系统 数字信号 在模拟信号通过量化和编码来转换成数字信号。 其中每一个采样点用N位二进制描述，位数越高越精细，同样，所占用的空间也越大。 奈奎斯特采样定理： 如果采样频率高于原始信号的最高频率两倍的时候，就可以不失真地还原模拟信号。 数字系统的层次结构 第5级 复杂数字系统，含第2到第4级的逻辑部件 第4级 复杂逻辑功能部件，如微处理器 第3级 逻辑功能部件，如加法器、计数器、乘法器 第2级 基本逻辑部件，如逻辑门、触发器等 第1级 电子元件，如二极管、三极管、电阻、电容 数字逻辑电路的类型 组合逻辑电路：无记忆功能 在任何时刻的稳定输出仅取决于该时刻的输入，而与电路过去的输入无关 类似于拨盘的锁，拨密码的次序没关系，最后总的顺序对就行了 时序逻辑电路：有记忆功能 在任何时刻的稳定输出不仅取决于该时刻的输入，而且与过去的输入相关 类似于电话，与拨号次序有关，能记住之前的数据 时序逻辑电路按照是否有统一的时钟信号进行同步还可以分为 同步时序逻辑电路 异步时序逻辑电路 二、逻辑代数 基本概念 格式：F=f(A1,A2,...,An)F=f(A_1,A_2,...,A_n)F=f(A1​,A2​,...,An​) 其中F为输出端数值，相当于y，f表示具体的函数关系，An表示各个参数 逻辑函数的相等 设有两个相同变量的逻辑函数 F1=f1(A1,A2,...,An)F_1=f_1(A_1,A_2,...,A_n)F1​=f1​(A1​,A2​,...,An​) F2=f2(A1,A2,...,An)F_2=f_2(A_1,A_2,...,A_n)F2​=f2​(A1​,A2​,...,An​) 则，对于两个逻辑函数，只有当逻辑变量 A1,A2,...,AnA_1,A_2,...,A_nA1​,A2​,...,An​ 中的任何一组取值，F1和F2的值都相同，才称F1和F2相等。 五个公理 +为或、⋅·⋅为与 公理1：交换律 对于任意逻辑变量A、B，有 A+B=B+AA+B=B+AA+B=B+A A⋅B=B⋅AA \\cdot B = B \\cdot AA⋅B=B⋅A 公理2：结合律 对于任意逻辑变量A、B、C，有 (A+B)+C=A+(B+C)(A+B)+C=A+(B+C)(A+B)+C=A+(B+C) (A⋅B)⋅C=A⋅(B⋅C)(A \\cdot B) \\cdot C = A \\cdot (B \\cdot C)(A⋅B)⋅C=A⋅(B⋅C) 公理3：分配律 对于任意逻辑变量A、B、C，有 A+(B⋅C)=(A+B)⋅(B+C)A+(B \\cdot C)=(A+B) \\cdot (B+C)A+(B⋅C)=(A+B)⋅(B+C) A⋅(B+C)=A⋅B+A⋅CA \\cdot (B + C) = A \\cdot B + A \\cdot CA⋅(B+C)=A⋅B+A⋅C 公理4：0-1律 对于任意的逻辑变量A A+0=AA+0=AA+0=A A+1=1A+1=1A+1=1 A⋅0=0A \\cdot 0 = 0A⋅0=0 A⋅1=AA \\cdot 1 = AA⋅1=A 公理5：互补律 对于任意的逻辑变量A，存在唯一的A‾\\overline{A}A，使得 A+A‾=1A + \\overline{A} = 1A+A=1 A⋅A‾=0A \\cdot \\overline{A} = 0A⋅A=0 八个定理 定理1 0 + 0 = 0 0 + 1 = 1 1 + 0 = 1 1 + 1 = 1 0 · 0 = 0 0 · 1 = 0 1 · 0 = 0 1 · 1 = 1 定理2 A+A=AA+A=AA+A=A A⋅A=AA \\cdot A=AA⋅A=A 定理3 A+A⋅B=AA + A \\cdot B =AA+A⋅B=A A⋅(A+B)=AA \\cdot (A +B)=AA⋅(A+B)=A 定理4 A+A‾B=A+BA + \\overline{A}B = A +BA+AB=A+B A⋅(A‾+B)=ABA \\cdot (\\overline{A}+B)=ABA⋅(A+B)=AB 定理5 A‾‾=A\\overline{\\overline{A}}=AA=A 定理6 A+B‾=A‾⋅B‾\\overline{A+B}=\\overline{A} \\cdot \\overline{B}A+B​=A⋅B A⋅B‾=A‾+B‾\\overline{A \\cdot B} = \\overline{A} + \\overline{B}A⋅B=A+B 定理7 AB+AB‾=AAB+A\\overline{B}=AAB+AB=A (A+B)⋅(A+B‾)=A(A+B)\\cdot(A+\\overline{B})=A(A+B)⋅(A+B)=A 定理8 A⋅B+A‾⋅C+B⋅C=A⋅B+A‾⋅CA \\cdot B + \\overline{A} \\cdot C + B \\cdot C = A \\cdot B + \\overline{A} \\cdot CA⋅B+A⋅C+B⋅C=A⋅B+A⋅C (A+B)⋅(A‾+C)⋅(B+C)=(A+B)⋅(A‾+C)(A+B)\\cdot (\\overline{A}+C) \\cdot (B+C) = (A+B)\\cdot (\\overline{A}+C)(A+B)⋅(A+C)⋅(B+C)=(A+B)⋅(A+C) 三、复合逻辑 与非逻辑 根据A⋅B‾=A‾+B‾\\overline{A \\cdot B} = \\overline{A}+\\overline{B}A⋅B=A+B，“与”和“非”可以产生“或”的关系 即与非逻辑可以实现与、或、非三种基本逻辑 与：F=A⋅B‾⋅1‾=A⋅B‾‾=A⋅BF=\\overline{\\overline{A\\cdot B}\\cdot 1}= \\overline{\\overline{A\\cdot B}}=A\\cdot BF=A⋅B⋅1=A⋅B=A⋅B （根据公理4） F=A⋅B‾⋅1‾=A⋅B‾‾+1‾=A⋅B+0=A⋅BF=\\overline{\\overline{A\\cdot B}\\cdot 1}=\\overline{\\overline{A \\cdot B}} + \\overline{1} = A\\cdot B + 0 = A \\cdot BF=A⋅B⋅1=A⋅B+1=A⋅B+0=A⋅B（根据定理6、公理4） 或：F=A⋅1‾⋅B⋅1‾‾=A‾⋅B‾‾=A+BF=\\overline{\\overline{A\\cdot 1}\\cdot \\overline{B \\cdot 1}} = \\overline{\\overline{A} \\cdot \\overline{B}} = A+BF=A⋅1⋅B⋅1=A⋅B=A+B（根据公理4、定理6） 非：A⋅1‾=A‾\\overline{A \\cdot 1} = \\overline{A}A⋅1=A（根据公理4） 或非逻辑 根据A⋅B‾=A‾+B‾\\overline{A \\cdot B} = \\overline{A} + \\overline{B}A⋅B=A+B，“或”和“非”可以产生“与”的关系 即或非逻辑可以实现与、或、非三种基本逻辑 与： F=A+0‾+B+0‾‾=A‾+B‾‾=A⋅BF=\\overline{\\overline{A+0}+\\overline{B+0}}=\\overline{\\overline{A}+\\overline{B}} = A \\cdot BF=A+0​+B+0​​=A+B​=A⋅B（根据公理4、定理6） 或： F=A+B‾+0‾=A+B‾‾=A+BF=\\overline{\\overline{A+B}+0}=\\overline{\\overline{A+B}}=A+BF=A+B​+0​=A+B​​=A+B（根据公理4） 非： F=A+0‾=A‾F=\\overline{A+0}=\\overline{A}F=A+0​=A（根据公理4） 与或非逻辑 与或非逻辑是由与、或、非三种逻辑复合形成的，可用逻辑函数表示为 F=AB+BC+CD+⋅⋅⋅‾F=\\overline{AB+BC+CD + \\cdot\\cdot\\cdot} F=AB+BC+CD+⋅⋅⋅​ 仅当每一个“与项”均为0时，才能使F为1，否则F为0 实现“与或非”运算功能的逻辑电路称为“与或非”门，符号为： 异或逻辑 两变量逻辑关系，可用逻辑函数表示为 F=A⊕B=A‾B+AB‾F=A \\oplus B = \\overline{A}B + A \\overline{B} F=A⊕B=AB+AB 逻辑功能： 变量A、B取值相同，F为0 变量A、B取值相异，F为1 实现“异或”运算功能的逻辑电路称为“异或”门，符号为： 逻辑性质 A⊕A=0A\\oplus A =0A⊕A=0 A⊕A‾=1A\\oplus \\overline{A} = 1A⊕A=1 A⊕0=AA\\oplus 0 = AA⊕0=A A⊕1=A‾A\\oplus 1 =\\overline{A}A⊕1=A A⊕B‾=A⊕B‾=A⊕B⊕1A\\oplus \\overline{B} = \\overline{A \\oplus B} = A \\oplus B \\oplus 1A⊕B=A⊕B​=A⊕B⊕1 A⊕B=B⊕AA\\oplus B = B \\oplus AA⊕B=B⊕A A⊕B⊕C=(A⊕B)⊕CA\\oplus B \\oplus C = (A \\oplus B)\\oplus CA⊕B⊕C=(A⊕B)⊕C A(B⊕C)=(AB)⊕(AC)A(B \\oplus C) = (AB)\\oplus(AC)A(B⊕C)=(AB)⊕(AC) 异或运算的多个变量中，若有奇数个变量的值为1，则运算结果为1 若有偶数个变量的值为1，则运算结果为0 可用于奇偶校验 同或逻辑 两变量逻辑关系，可用逻辑函数表示为 F=A⊙B=A‾⋅B‾+ABF=A\\odot B = \\overline{A} \\cdot \\overline{B} + AB F=A⊙B=A⋅B+AB 逻辑功能： 变量A、B取值相同，F为1 变量A、B取值相异，F为0 实现“同或”运算功能的逻辑电路称为“同或”门，符号为： 同或运算的多个变量中，若有奇数个变量的值为0，则运算结果为0 若有偶数个变量的值为0，则运算结果为1 对偶运算是符号和数值全部相反，1->0,0->1,与->或，或->与 四、集成门电路 集成电路分类： 双极型集成电路：采用双极型半导体器材作为元件 TTL（三极管·三极管电路）、ECL（射级耦合电路）、I2L（集成注入电路） 单极型集成电路：金属-氧化物半导体场效应管作为元件（MOS集成电路） PMOS、NMOS、CMOS 简单逻辑门电路 与门 或门 非门 TTL型集成门电路 在数字电路中，用逻辑电平来表示逻辑常量“1”和“0”。逻辑电平有高电平（H）和低电平（L）之分，它们表示的都是一定的电压范围，而不是一个固定不变的值。 例如在TTL电路中，常常规定标准高电平VH=3.6V，标准低电平VL=0.2V，一般在00.8V都算低电平，25V都算作高电平。 TTL与非门 工作原理示例： TTL非门 跟与非门的区别就是输入端变成了一个 TTL或非门 TTL与或非门 集电极开路与非门（OC门） 作用：实现“线与逻辑” 只要有一个门输出为低电平，输出F便为低电平 仅当两个门的输出均为高电平时，输出F才为高电平 逻辑功能：两个与非门输出相“与” 三态门 将一个输入端变成了使能信号EN 三态门原理 1.当EN=1时（高电平） 此时输出F=AB‾F=\\overline{AB}F=AB 2.当EN=0时（低电平） 此时F为高阻态，无输出信号。 三态门的应用 五、MOS管 基本概念 MOS管有三个极组成，分别是 漏极：用D（Drain）表示 栅极：用G（Gate）表示 源极：用S（Source）表示 可分为N沟道增强型MOS管、P沟道增强型MOS管和CMOS管，CMOS指两者都使用 当栅极为高电平时，NMOS管导通，PMOS管截止 当栅极为低电平时，NMOS管截止，PMOS管导通 即NMOS工作状态相当于NPN三极管，PMOS工作状态相当于PNP三极管 当V1等于0时，Tp为PMOS管，导通；TN为NMOS管，截止 所以Vo的电压等于VDD的电压，为高电压，所以F为1 当EN=0时，TP’和TN’都导通，相当于导线，即等效于正常的反相器 当EN=1时，TP’和TN’都截止，相当于断路，即F处于断路，为高阻状态。 六、正逻辑与负逻辑 正逻辑 用高电平表示逻辑1，低电平表示逻辑0 负逻辑 用高电平表示逻辑0，低电平表示逻辑1 "},{"title":"CSS学习笔记","date":"2020-03-16T07:53:56.000Z","url":"/2020/03/16/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["css","/tags/css/"],["HTML","/tags/HTML/"]],"categories":[["HTML","/categories/HTML/"]],"content":"css的一些学习笔记 分类 元素内嵌样式表 作为标签的全局属性存在，可以直接通过style=&quot;&quot;的形式进行添加 test 文档内嵌样式表 在&lt;header&gt;&lt;/header&gt;标签内进行添加 外部样式表 在外部新建css文件，通过html中的link标签进行连接,例如在同一目录下新建一个styles.css进行导入 优先级 元素内嵌样式表&gt;文档内嵌样式表&gt;外部样式表 选择器 元素选择器 直接使用元素名进行选择，对所有a元素适用 选择所有元素，只要将p去掉，用*代替即可 类选择器 使用html的class属性来进行区分，在css中使用.classname来进行选择 也可以指定特定的HTML元素使用class。 如上所示，所有的class=&quot;center&quot;的 p 元素使用该样式表，其余元素不变。 如上所示，所有的class=&quot;center&quot;元素内的 p 元素使用该样式表，其余元素不变。 ID选择器 使用html的id属性进行区分，在css中使用#idname来进行选择 根据属性选择 根据属性选择元素，使用[属性名] 示例中通过使用[href]对href属性进行了选择，方括号中也可以添加具体的值来针对该属性值为某一具体值的元素进行选择，例如选择第一个a标签包含的元素，可使用[href=&quot;com1&quot;]来进行选择。 后代选择器 使用空格符号 选中某元素中的所有后代元素，如下所示，选中是&lt;div&gt;中的所有&lt;p&gt;标签 子元素选择器 使用大于号&gt; 选中某元素中的直接后代元素。如下所示，选中是直接在div之下的&lt;p&gt;标签 相邻兄弟选择器 使用加号+ 选择是在某个元素之后第一次出现的另一个元素，如下所示，选中的是&lt;div&gt;结束后的第一个&lt;p&gt;标签 后续兄弟选择器 使用波浪符号~ 选择的是在某个元素之后的所有另一个元素，如下所示，选中的是&lt;div&gt;结束后的所有&lt;p&gt;标签（未包含在其他元素内） 背景（Background） 背景颜色 使用background-color属性 背景图像 使用background-image属性 背景的水平或垂直平铺 使用background-repeat属性 示例 背景位置 使用background-position属性 方式1 可选值有left、right、top、center、bottom 一个参数是水平方向，另一个参数是竖直方向，如果只指定一个参数，那另一值默认为center。 方式2 第一个值是水平位置，第二个值是垂直位置，左上角为0%，0%，右下角有100%，100%，如果只设定了一个值，那另一个值默认为50%。默认值0%，0%。 方式3 使用像素进行定位，第一个值是水平位置，第二个值是垂直位置，左上角是0，0。如果只设定了一个值，那另一个值默认为50%。可以混用%和px。 背景固定方式 使用background-attachment属性 可选值scoll、fixed、local scoll表示背景图片随页面滚动而滚动，是默认值 fixed表示背景图片固定，不会随页面滚动而滚动 local表示背景图片会随着元素内容的滚动而滚动 背景大小 使用background-size属性 可选值length、percentage、cover、contain length：通过两个像素大小来表示，第一个值为宽度，第二个值为高度，若只设置一个参数，另一个参数为auto（自动） perccentage：通过相对于背景定位区域的比例来表示，第一个值为宽度，第二个值为高度，若只设置一个参数，另一个参数为auto（自动） cover：保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小 container：保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小 背景相对位置 使用background-origin属性 可选值padding-box、border-box、content-box padding-box：背景图像关于填充框的相对位置 border-box: 背景图像关于边界框的相对位置 content-box：背景图像关于内容库的相对位置 示例 指定绘图区的背景 使用background-clip属性 可选值padding-box、border-box、content-box padding-box：默认值。背景绘制在边框方框内（剪切成边框方框） border-box: 背景绘制在衬距方框内（剪切成衬距方框） content-box：背景绘制在内容方框内（剪切成内容方框）。 示例 文本（Text） 颜色 使用color属性 可以使用颜色名、十六进制颜色、rgb颜色、rgba颜色 对齐方式 使用text-align属性 可选值left、right、center、justify 分别对应左端对齐，右端对齐，居中，两端对齐。 文本修饰（下划线等） 使用text-decoration属性 参数值overline、underline、line-through、none 分别对应上划线、下划线、删除线、无线。 可以多设几个参数值添加多条线，例如 后面可以添加颜色值和线型，例如虚线——dotted，波浪线——wavy 示例： 大小写 使用text-transform属性 可选项none、capitalize、uppercase、lowercase none：默认，无格式 capitalize：每个单词首字母大写 uppercase：所有字母大写 lowercase：所有字母小写 缩进 使用text-indent属性 设置固定的缩进值，如50px; 设定基于父元素宽度的百分比的缩进 行高 使用line-height属性 可选项number、length、% number：设置数字，比如2-两倍行距 length：设置固定行间距，默认正常的行间距为20px; %：用百分比来进行设置 小行距 小行距 正常行距 正常行距 大行距 大行距 盒子模型 Margin（外边框）:Border外的边框，透明，与其他元素之间的距离 Border（边框）：围绕在内边框和内容外的边框，是最直观可见的边框 Padding（内边框）：内容部分与边框之间的距离 Content（内容）：盒子模型的内容部分是我们要显示的内容，例如文本和图像 我们设定的width和height属性指的是Content部分的宽度和高度 总宽度 = 内容宽度（width）+ 内边框宽度*2 + 边框宽度*2 + 外边框宽度*2 边框（Border） 边框样式 使用border-style属性 可选项：（随颜色不同，效果不同） p.none {border-style:none;} p.dotted {border-style:dotted;} p.dashed {border-style:dashed;} p.solid {border-style:solid;} p.double {border-style:double;} p.groove {border-style:groove;} p.ridge {border-style:ridge;} p.inset {border-style:inset;} p.outset {border-style:outset;} p.hidden {border-style:hidden;} none——无边框。 dotted——虚线边框。 dashed——虚线边框。 solid——实线边框。 double——双边框。 groove——凹槽边框。 ridge——垄状边框。 inset——嵌入边框。 outset——外凸边框。 hidden——隐藏边框。 边框宽度 使用border-style属性 分别设置四边框 - border-style:属性1，属性2，属性3，属性4; &emsp;&emsp;上->右->下->左 - border-style:属性1，属性2，属性3 &emsp;&emsp;上->左右->下 - border-style:属性1，属性2 &emsp;&emsp;上下->左右 - border-style:属性1 &emsp;&emsp;上下左右属性相同 示例 p.test{ border-top:thick double #ff0000; border-left:2px solid green; border-right:4px dotted #00ffff; border-bottom:hidden; } p.test2{ border-left:5px solid #33b6ee; background-color:rgba(207,235,246); line-height:3; Padding-left:10px; } 示例 示例2 轮廓 （outline） 轮廓（outline）是在border外的一条线，属性值与Border一致，outline不占用额外空间。 test 圆角（border-radius） 使用border-radius属性，单位为像素px 盒子阴影（box-shadow） 使用box-shadow属性 第一个参数：水平阴影的位置（为正即右移xxpx，为负左移） 第二个参数：垂直阴影的位置（为正即下移，为负上移） （第三个参数，可选）：模糊程度 （第四个参数，可选）：阴影的大小 （第五个参数，可选）：阴影颜色 边界图片（border-image） 使用border-image:url(image-url)属性 使用图片作为边框样式，示例 外边框（Margin） margin项有两个可选项，length和auto auto：设置浏览器边距，取决于浏览器 length：固定的具体数值 margin:边距1，边距2，边距3，边距4; 上-&gt;右-&gt;下-&gt;左 margin:边距1，边距2，边距3 上-&gt;左右-&gt;下 margin:边距1，边距2 上下-&gt;左右 margin:边距1 上下左右边距相同 内边框（padding） padding项，内容与margin相同 尺寸（Dimension） 最大高度——max-height 最大宽度——max-width 最小高度——min-height 最小宽度——min-width 都可以使用像素值或百分比来进行设置。 显示（display&amp;visibility） 可见性 使用display和visibility标签 通过设置display:none和visibility:hidden标签来隐藏元素。 visibility:hidden，可以隐藏元素，但是元素仍然占用空间，对布局会有影响。 display:none，可以隐藏元素，同时元素不占用空间。 👀块元素和内联元素 块级元素特性： 总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示; 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制; 内联元素(inline)特性： 和相邻的内联元素在同一行; 宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变，就是里面文字或图片的大小; 块级元素主要有： address , blockquote , center , dir , div , dl , fieldset , form , h1 , h2 , h3 , h4 , h5 , h6 , hr , isindex , menu , noframes , noscript , ol , p , pre , table , ul , li 内联元素主要有： a , abbr , acronym , b , bdo , big , br , cite , code , dfn , em , font , i , img , input , kbd , label , q , s , samp , select , small , span , strike , strong , sub , sup ,textarea , tt , u , var 👀CSS中，可以通过修改dispaly属性来改变块级显示或是内联显示 display:block —— 显示为块级元素 display:inline —— 显示为内联元素 display:inline-block —— 显示为内联元素，表现为同行显示并可修改高度内外边距等属性 例如通常将&lt;ul&gt;加上display:inline或display:inline-block属性，来使得列表水平显示，用作导航栏之类。 定位（position） 使用position属性，和top、bottom、left、right属性配合使用。 可选项：static、fixed、relative、absolute、sticky static：默认值，没有定位，不受top、left等属性的影响。 fixed：相对于窗口的固定位置，即使窗口滚动它也不动。通过四个属性值设定具体位置。 relative：相对于该元素的正常位置。但是占用空间不变，例如两个标题，占用两行，通过top属性使第二行覆盖第一行，则第二行所占位置仍然存在，成为空白。 absolute：绝对定位，相对于最近的以定位的父元素，若没有则相对于&lt;html&gt;，absolute定位的元素不占用空间，不影响布局，相当于“浮于文字上方” sticky：sticky定位的元素在没有移出窗口时相当于relative，在移出窗口后就位于窗口最上方，就是顶部菜单栏的形式。 此外，可以通过z-index属性来指定元素的堆叠顺序。相当于手动规定不同的图层顺序。z-index的值越大，图层就在越上层。如果没有定义z-index属性的话，最后定位在HTML代码中的元素将在最前面。 裁剪（clip） top：表示从上方截去多少像素 right：表示左侧剩余多少像素 bottom：表示上方剩余多少像素 left：表示从左侧截去多少像素 🐷就很诡异 溢出处理（overflow） 使用overflow属性 可选项：visible、hidden、scroll、auto visible：默认值，溢出了就在下方继续显示 hidden：溢出后将溢出内容隐藏 scroll：提供一个滚动条 auto：在溢出后再提供一个滚动条以供查看内容 浮动（float&amp;clear） 可选项left、right分别对应靠左和靠右 使用clear可规定元素周围不出现浮动元素，可选项left、right、both 图片的浮动效果类似于word中“文字环绕型” 布局\\对齐 元素居中对齐 使用margin:auto来进行元素居中对齐 元素居中对齐 文本居中对齐 使用text-align属性， 图片居中对齐 使用margin:auto 同样使用margin:auto来设置居中对齐，不过需要将图片使用display:block以块形式显示 使用div 可以在图像外层套一层&lt;div&gt;标签，并在div的样式表中设置text-align:center 左右对齐 使用position 使用position:absolute属性来对齐元素，设定left:0px;进行左对齐，right:0px右对齐 使用float 使用float:left左对齐，float:right右对齐。 但是当子元素的高度大于父元素时，子元素将溢出。这时可以给父元素添加overflow:auto来解决子元素溢出的问题。示例 垂直居中对齐 使用padding 即在头部顶部使用padding，即可实现垂直居中 垂直居中 使用line-height 设置line-hright的值与height的值相等即可实现垂直居中 垂直居中 伪类 在选择器后添加冒号:来选择伪类，常用举例： 👀多列 创建多列（column-count） 使用column-count属性，通过指定后面的数字来规定将元素分为几列 上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下----- 列与列的间隙（column-gap） 使用column-gap属性来设定列与列之间的间隙，下示代码将间隙设为50px; 上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下----- 列边框 边框样式 使用column-rule-style属性 边框颜色 使用column-rule-color属性 边框厚度 使用column-rule-width属性 缩写 可使用column-rule属性来缩写 示例 上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下-----上述代码说明将元素分成3列-----分割一下----- 指定元素跨越多少列（column-span） 使用column-span属性 可选项1、all，示例 列宽度（column-width） 使用column-width属性可以设定每列的宽度，会根据宽度自动分列，不用规定列数。 上述代码将列宽度设定为100px，在电脑上一般为5列。。上述代码将列宽度设定为100px，在电脑上一般为5列。。上述代码将列宽度设定为100px，在电脑上一般为5列。。上述代码将列宽度设定为100px，在电脑上一般为5列。。 多媒体查询（@media） 格式： mediatype表示媒体类型，通过not|only|all来进行筛选 mediatype的可选项： print：打印机 screen：用于电脑屏幕、平板、智能手机等 speech：用于屏幕阅读器 筛选项： not：不应用于后述媒体类型 only：只应用于后述媒体类型 all：应用于所有媒体类型，使用all时可以省去媒体类型，也可以只写媒体类型省去all expressions： 表达式，当所选设备满足表达式时应用css样式 示例： "},{"title":"数据库系统原理：第二章关系数据库（二）","date":"2020-03-13T10:44:09.000Z","url":"/2020/03/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["数据库系统原理","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"categories":[["数据库系统原理","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"content":"⭐️ 数据库系统原理：第二章关系数据库中的关系代数的相关内容。 ⭐️关系代数 关系代数式一种抽象的查询语言，它用对关系的运算来表达查询。 其中基本运算为（5种）： 并 ∪∪∪ 、 差 −-− 、笛卡尔积 ××× 、 选择 σ\\sigmaσ 、 投影 ∏\\prod∏ 剩余运算（3种）： 交 ∩∩∩ 、 连接 ⋈\\bowtie⋈ 、 除 ÷÷÷ 剩余运算都可以用基本运算表示： 交运算 R∩S=R−(R−S)R∩S=R-(R-S)R∩S=R−(R−S) 连接运算 R⋈AθB=σAθB(R×B)R\\mathop{\\bowtie}\\limits_{AθB} = \\sigma_{AθB}(R×B)RAθB⋈​=σAθB​(R×B) 除运算 R(X,Y)÷S(Y)=∏X(R)−∏X(∏X(R)×∏Y(S)−R)R(X,Y)÷S(Y)=\\prod_X(R)-\\prod_X(\\prod_X(R)×\\prod_Y(S)-R)R(X,Y)÷S(Y)=∏X​(R)−∏X​(∏X​(R)×∏Y​(S)−R) 一、基本运算 （1）R，t∈R，t[Ai] 设关系模式为 R(A1,A2,…,An) 它的一个关系设为R t∈R表示 t 是 R 的一个元组 t[Ai]则表示元组 t 中相应于属性 Ai 的一个分量 （2）A，t[A]，A‾\\overline{A}A 若A={Ai1，Ai2,…,Aik}，其中Ai1，Ai2,…,Ain是A1,A2,…,An中的一部分，则A称为属性列或属性组 t[A]=(t[Ai1]，t[Ai2],…,t[Aik])表示元组t在属性列A上诸分量的集合。 A‾\\overline{A}A则表示{A1,A2,…,An}中去掉{Ai1，Ai2,…,Aik}后剩余的属性组 （3）trts⏠\\overgroup{t_rt_s}tr​ts​​ R为n目关系，S为m目关系。 tr∈R，ts∈S，trts⏠\\overgroup{t_rt_s}tr​ts​​称为元组的连接 trts⏠\\overgroup{t_rt_s}tr​ts​​是一个n+m列的元组，前n个分量是R中的一个n元组，后m个分量是S中的一个m元组 （4）象集Zx 给定一个关系R（X，Z），X和Z为属性组。 当t[X]=x时，x在R中的象集为： Zx={t[Z]∣t∈R,t[X]=x}Z_x=\\{t[Z]|t∈R,t[X]=x\\} Zx​={t[Z]∣t∈R,t[X]=x} 它表示R中属性组X上值为x的诸元组在Z上分量的集合 示例： X Z X1 Z1 X1 Z2 X1 Z3 X2 Z2 X2 Z3 X3 Z1 X3 Z3 则： X1在R中的象集： Zx1={Z1,Z2,Z3} X2在R中的象集： Zx2={Z2,Z3} X3在R中的象集： Zx3={Z1,Z3} 二、传统集合运算 并 R和S 具有相同的目n 相应的属性取自同一个域 R∪S 仍为n目关系，由属于R或属于S的元组组成 R∪S=t∣t∈R∨t∈SR∪S={t|t∈R∨t∈S} R∪S=t∣t∈R∨t∈S 示例： 差 R和S 具有相同的目n 相应的属性取自同一个域 R-S 仍为n目关系，由属于R而不属于S的元组组成 R−S=t∣t∈R∧t∉SR-S={t|t∈R∧t\\notin S} R−S=t∣t∈R∧t∈/​S 示例： 以上图为例，则R-S为: A B C a1 b1 c1 S-R为: A B C a1 b3 c2 交 R和S 具有相同的目n 相应的属性取自同一个域 R∪S 仍为n目关系，由既属于R又属于S的元组组成 R∪S=t∣t∈R∧t∈SR∪S={t|t∈R∧t∈S} R∪S=t∣t∈R∧t∈S 示例： 以上图为例，则R∩S为: A B C a1 b2 c2 a2 b2 c1 笛卡尔积（积） R：n目关系，k1个元组；S：m目关系，k2个元组 R×××S 列：（n+m）列元组的集合 行：k1×××k2个元组 三、关系特有操作 选择 选择又称为限制 选择元素符的含义 在关系R中选择满足给定条件的诸元组 σF(R)\\sigma_F(R)σF​(R)，F为选择条件，是一个逻辑表达式 基本形式为：XθY θ表示比较运算符，它可以是&gt;,≥,&lt;,≤,=,或≠&gt;,\\ge,&lt;,\\le,=,或\\neq&gt;,≥,&lt;,≤,=,或​= 例如： 查询信息系（IS系）全体学生 σSdept=′IS′(Student)\\sigma_{Sdept=&#x27;IS&#x27;}(Student)σSdept=′IS′​(Student) 结果： | Sno | Sname | Ssex | Sage | Sdept | | :-------: | :—: | :—: | :—: | :—: | | | 201215125 | 张立 | 男 | 19 | IS | | 201215126 | 李四 | 女 | 20 | IS | 可以看出选择出来都是Sdept属性为IS的信息。 投影 从R中选择若干属性列组成新的关系 ∏A(R)=t[A]∣t∈R，A:R中的属性列\\prod_A(R)={t[A]|t∈R}，A:R中的属性列 A∏​(R)=t[A]∣t∈R，A:R中的属性列 例如： 查询学生的姓名和所在系。即求Student关系上学生姓名和所在系两个属性上的投影∏Sname,Sdept(Student)\\prod_{Sname,Sdept}(Student)∏Sname,Sdept​(Student) 结果： Sname Sdept 李勇 CS 刘晨 CS 王铭 MA 张三 IS 连接 连接运算的含义： 从两个关系的笛卡尔积中选取属性间满足一定条件的元组 R⋈AθBS={trts⏠∣tr∈R∧ts∈S∧tr[A]θts[B]}R\\mathop{\\bowtie}\\limits_{AθB}S =\\{ \\overgroup{t_rt_s}|t_r∈R∧t_s∈S∧t_r[A]θt_s[B]\\} RAθB⋈​S={tr​ts​​∣tr​∈R∧ts​∈S∧tr​[A]θts​[B]} A和B：分别为R和S上度数相等且可比的属性组 θ比较运算符 连接运算从R和S关系的广义笛卡尔积R×××S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组。 两类常用连接运算 等值连接 θ为“=”的连接运算称为等值连接 从关系R和S的广义笛卡尔积中选取A、B属性值相等的那些元组。 自然连接 自然连接是一种特殊的等值连接 两个关系中进行比较的分量必须是相同的属性组 在结果中会把重复的属性列去掉 R和S需要具有相同的属性组 示例： 悬浮元组 在两个关系R和S做自然连接中，关系R上的某些元组可能在关系S上没有属性值相等的元组，那么这些元组会被遗弃，称为悬浮元组 外连接 如果把悬浮元组也保存在结果关系中，而在其他属性上填空值（NULL），称为外连接 如果只保留左边关系R中的悬浮元组，则称为左外连接 如果只保留右边关系S中的悬浮元组，则称为右外连接 除运算 给定关系R（X，Y）和S（Y，Z），其中X，Y，Z为属性组 R与S除运算得到一个新关系P（X），P是R中满足元组在X上分量值x的象集Yx包含S在Y上投影的集合的元组在X属性列上的投影。 这里可以看到，在关系R中，A可以取四个值（a1，a2，a3，a4） a1的象集为 {(b1，c2)，(b2，c3)，(b2，c1)} a2的象集为 {(b3，c7)，(b2，c3)} a3的象集为 {(b4，c6)} a4的象集为 {(b6，c6)} 而S在（B，C）上的投影为 {(b1，c2)，(b2，c1)，(b2，c3)} 在这个例子中，只有a1的象集包含了S在（B，C）属性组上的投影 所以R÷S={a1} 只要出现了全部、所有字样的题目都需要用到除运算"},{"title":"定点数与浮点数","date":"2020-03-12T09:26:03.000Z","url":"/2020/03/12/%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":" 定点数 定点数的格式（小数点位置固定不变） 定点整数（小数点约定在最低位的右边，最高位为符号位） Xn-1 Xn-2 … X0 . --(小数点在最低位右侧) 定点小数（最高位为符号位，小数点约定在符号位右侧） Xn-1 . --(小数点在符号位右侧) Xn-2 … X0 定点数的表示范围 无符号定点整数：0 ≤\\le≤ X ≤\\le≤ 2n-1 有符号定点整数（补码）：-2n-1 ≤\\le≤ X≤\\le≤ 2n-1-1 有符号定点小数（补码）：-1 ≤\\le≤ X ≤\\le≤ 1-2-n+1 定点整数的真值是定点小数的真值的2n+1倍 浮点数 定点数与浮点数的比较： 定点数表示数的范围比较小，运算容易发生溢出 浮点数表示数的范围比较大，运算不容易发生溢出 浮点数格式： 尾数决定了数的精度，阶码决定了数的范围。 其中Es为阶符，即从这开始到尾符之间是阶码 Ms为尾符，表明尾数部分从此开始。 浮点数的规格化表示 浮点数的规格化形式 M&gt;0（正数形式）：0.1xx…，即12≤M≤\\frac{1}{2}\\le M\\le21​≤M≤ 1-2-n+1 M&lt;0（负数形式）：1.0xx…，即-1 ≤M≤−12−\\le M \\le -\\frac{1}{2}-≤M≤−21​− 2-n+1 （-1/2）补 = 1.100…0 规格化浮点数 尾数进行移位，阶码做相应加减运算，直至尾数满足要求（类比科学记数法） 左规：尾数每左移一次，阶码相应减1 右规：尾数每右移一次，阶码相应加1 规格化的意义 使机器真值的表示形式唯一 充分利用尾数更多的有效数字 ✨规格化浮点数的表数范围 设阶码：p位（含阶符），移码；尾数：m位（含尾符），补码 最大正数：0.11…1××× 211…1 (1−2−m+1)⋅2(2p−1−1)(1-2^{-m+1})·2^{(2^{p-1}-1)} (1−2−m+1)⋅2(2p−1−1) 最小正数：0.10…0××× 200…0 12⋅2−2p−1\\frac{1}{2}·2^{-2^{p-1}} 21​⋅2−2p−1 最大负数：1.01…1××× 200…0 −(12+2−m+1)⋅2−2p−1-(\\frac{1}{2}+2^{-m+1})·2^{-2^{p-1}} −(21​+2−m+1)⋅2−2p−1 最小负数：1.00…0××× 211…1 −2(2p−1−1)-2^{(2^{p-1}-1)} −2(2p−1−1) 浮点数既可以表示数值范围很大的数，也可以表示数值范围很小但精确度很高的数 阶码的位数（p），决定表示数的范围 尾数的位数（m），决定表示数的精度 浮点数的溢出判断 在最大负数和最小正数之间的称为下溢区 大于最大正数以及小于最小负数的区域称为上溢区 溢出判断只是对规格化数的 阶码 进行判断 下溢：自动视为0 上溢：溢出处理 "},{"title":"机器数的表示方法","date":"2020-03-12T06:38:26.000Z","url":"/2020/03/12/%E6%9C%BA%E5%99%A8%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"包括原码、反码、补码、移码的一些操作。 原码 用最高位表示符号（0——正，1——负），其他位表示数值的绝对值 例如： x1=+45 ===&gt; [x1]原 = 00101101B x2= -45 ===&gt; [x2]原 = 10101101B 在原码中，0的表示不唯一 [+0]原 = 00000000B [- 0]原 = 10000000B 反码 用最高位表示符号（0——正，1——负） 正数的反码：与原码相同 负数的反码：符号位不变，其余位按位取反 例如： x1=+45 ===&gt; [x1]原 = 00101101B ===&gt; [x1]反 = 00101101B x2= -45 ===&gt; [x2]原 = 10101101B ===&gt; [x2]反 = 11010010B 在反码中，0的表示不唯一 [+0]反 = 00000000B [- 0]反 = 11111111B ⭐️补码 用最高位表示符号（0——正，1——负） 在补码中，0的表示唯一 [+0]补 = 00000000B [- 0]补 = 00000000B 所以将剩下的[100…0]位表示为最大负数，-2n 补码的几种计算方式 本例中的取反+1等效于-1取反 第一种方法 正数的补码：和原码相同 负数的补码：符号位不变，数值位按位取反 ，末位+1 例如： x1=+45 ===&gt; [x1]原 = 00101101B ===&gt; [x1]补 = 00101101B x2= -45 ===&gt; [x2]原 = 10101101B ===&gt; [x2]补 = 11010011B 第二种方法 正数的补码：和原码相同 负数的补码：从最低位（最右侧）起，到出现第一个1以前原码中的数字不变，以后逐位取反，符号位不变。 例如： x1=-101 0111B X2=-111 0000B [x1]原 = 1101 0111B ===&gt; [x1]补 = 1010 1001B //最右侧起第一个1是右侧第一位，所以从右侧第二位起到符号位为止，中间的位全部取反 [x2]原 = 1111 0000B ===&gt; [x2]补 = 1001 0000B //最右侧起第一个1是右侧第5位，所以从右侧第一位到第五位不变，第六位起到符号位为止，中间全部取反 第三种方法 正数的补码：和原码相同 负数的补码：相对应的正数的补码全部取反（包括符号位），在末位+1 例如： [x1] = -45 [-x1] = +45 [-x1]补 = [-x1]原 = 0010 1101B [x1]补 = 11010011B 同样的，[-x1]补也可以通过[x1]补全部取反+1得到，说明一个数的正负补码可以互相通过全部位取反+1得到 例如： 已知一个数的补码为[1101 0011B]，那么由符号位为1可知该数为负，其正数的补码由全部位取反+1得到，为[0010 1101B]，算出十进制数为+45（相当于该数绝对值为45），已知原数为负，所以该数为-45. 第四种方法 正数的补码：和原码相同 负数的补码：【2n-|x|】的补（原）码（因为是正数） 例如： 求-7的补码，因为-7需要四位二进制表示[1111B]，所以2n=24=16 那么24-|-7|=9，所以-7的补码就是9的补码，即1001B 补码的运算 补码的符号位也参与运算 加法：[X+Y]补 = [X]补 + [Y]补 减法：[X-Y]补 = [X]补 + [-Y]补 补码的算术移位 符号位在移位时不变，正数左右移位都补0，负数向右移位空来的位补1，左移空出来的位补0 例如： [X]原 = 1001 ==&gt; [x]补 = 1111 右移一位（相当于除以2（位数越高越接近除以2））：1111 -&gt; 1111 = 1001 = -1，因为1除以2余1 左移一位（相当于乘以2，同理）：1111 -&gt; 1110 = 1010 = -2 ✨当符号位与最高位（最左位）不同时，左移会溢出 例如： 0.1101[补] = 0.1101[原] = +13 那么左移乘以2应该为26，但26无法用4位二进制表示，所以溢出 0.1101左移后为0.1010 = +12 != 26 1.0110[补] = 1.1010[原] = -10 那么左移乘以2应该为-20，同样无法用4位二进制表示，所以溢出 1.0110左移后为1.1100[补] = 1.0101[原] = -5 != -20 移码 定义：[X]移 = 2n +X (-2n &lt;= X &lt;= 2n-1) 用最高位表示符号，其中1——正，0——负 移码的计算方法：补码的符号位取反，数值位不变 例如： x = -4, [x]原 = 1100 -&gt; [x]补 = 1100 -&gt; [x]移 = 0100 or 2n = 23 = 8 = 1000, [x]移 = [8]原 + [x]原 = 1000+1100 = 0100 真值越大，对应的移码也越大 在移码中，0的表示是唯一的 [x]移 = 2n+0 = 1000…0 移码的加减运算 加法：[X]移 + [Y]移 = [X+Y]补 然后符号位取反 减法：[X]移 - [Y]移 = [X-Y]补 然后符号位取反"},{"title":"数据库系统原理：第二章关系数据库（一）","date":"2020-03-07T05:21:09.000Z","url":"/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["数据库系统原理","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"categories":[["数据库系统原理","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"content":"数据库系统原理：第二章关系数据库中的关系模型的相关内容。 关系模型 一、关系数据结构 1.1概念 1.域及笛卡尔积 对应关系 属性为单列，例如学号 值即为单个属性值，例如201501001 关系型：模式即为图中第一行，是所有属性的集合 关系实例为图中第二行，是一条具体记录 域为取值范围，例如性别的域为{‘男’，‘女’} 了解了域的概念之后，可以在多个域的基础上计算笛卡尔积，给定一组域D1,D2,D3.....DnD_1, D_2, D_3.....D_nD1​,D2​,D3​.....Dn​，允许其中某些域是相同的，那么D1,D2,D3.....DnD_1, D_2, D_3.....D_nD1​,D2​,D3​.....Dn​的笛卡尔积为 D1×D2×D3×.....×Dn={(d1,d2,....,dn)∣di∈Di,i=1,2,....,n}D_1×D_2×D_3×.....×D_n=\\{(d_1,d_2,....,d_n)|d_i∈D_i,i=1,2,....,n\\} D1​×D2​×D3​×.....×Dn​={(d1​,d2​,....,dn​)∣di​∈Di​,i=1,2,....,n} 也就是D1,D2,D3.....DnD_1, D_2, D_3.....D_nD1​,D2​,D3​.....Dn​中所有可能的组合，笛卡尔积可以看做是关系的“域” 其中，D1,D2,D3.....DnD_1, D_2, D_3.....D_nD1​,D2​,D3​.....Dn​各自的域的大小之积称为基数 例如，给出3个域： D1D_1D1​=导师集合SUPERVISOR={张一，张二} D2D_2D2​=专业集合SUPERVISOR={计算机，软件} D3D_3D3​=研究生集合POSTGRADUATE={李三，李四，李五} 那么D1×D2×D3D_1×D_2×D_3D1​×D2​×D3​= {(张一，计算机，李三)，(张一，计算机，李四)，(张一，计算机，李五) (张一，软件，李三)， (张一，软件，李四)， (张一，软件，李五) …} 基数为2∗2∗3=122*2*3=122∗2∗3=12，表示成二维表即： SUPERVISOR SUPERVISOR POSTGRADUATE 张一 计算机 李三 张一 计算机 李四 张一 计算机 李五 张一 软件 李三 张一 软件 李四 张一 软件 李五 张二 计算机 李三 … 2.关系 D1×D2×D3×....×DnD_1×D_2×D_3×....×D_nD1​×D2​×D3​×....×Dn​的子集叫作在域D1,D2,D3.....DnD_1, D_2, D_3.....D_nD1​,D2​,D3​.....Dn​上的关系，表示为 R(D1,D2,....,Dn)R(D_1,D_2,....,D_n) R(D1​,D2​,....,Dn​) RRR：关系名 nnn：关系的目或度 3.元组 关系中的每个元素(d1,d2,....,dnd_1,d_2,....,d_nd1​,d2​,....,dn​)叫作一个nnn元组，简称元组，通常用ttt表示。 4.属性 同Excel表，即列，每列都得有列名，称为属性，n目关系必有n个属性 ⭐5.码 候选码 若关系中的某一属性组的值能唯一标识一个元组，则称该属性组为候选码 简单的情况：候选码只包含一个属性。 全码 最极端的情况中，关系模式的所有属性组是这个关系模式的候选码，成为全码 注意点 任何关系必有码 任何关系必有主码，且主码唯一 任何关系必有候选码，但候选码可以不唯一 当关系只有一个候选码时，该关系的码就是其候选码也就是主码 主码时候选码的子集，即主码一定包含在候选码中，由开发者在候选码中任选其一。 例如： 学号 姓名 性别 专业 身份证号 201501001 张三 男 软件工程 6666666666666 在该示例中，候选码为{学号，身份证号}，因为学号和身份证号都能唯一确定学生身份，主码则为两者二选其一，比如学号。 6.关系类型 关系可以有三种类型 基本表 查询表（基本表进行数据筛选后的表） 视图表 当n=1时，称该关系为单元关系和一元关系 当n=2时，称该关系为二元关系 7.基本关系的性质 列是同质的，即一列中数据类型和意义相同 不同的列可出自同一个域，即取值范围可以相同 列的次序可以交换 任意两个元组的候选码不能相同，因为候选码需要满足可以唯一确定一条记录的性质 行的次序可以交换 分量必须取原子值，即分量不可再分，出现表中表的情况 1.2 关系模式 1.什么是关系模式 关系模式是型 关系是值 关系模式是对关系的描述 元组集合的结构 属性构成 属性来自的域 属性与域之间的关系 完整性约束条件 2.定义关系模式 关系模式可以形式化地表示为： R(U,D,DOM,F)R(U,D,DOM,F) R(U,D,DOM,F) RRR 关系名 UUU 组成关系的属性名集合 DDD UUU中属性所来自的域 DOMDOMDOM 属性向域的映像集合 FFF 属性间数据的依赖关系的集合 ⭐示例: STUDENT(U,D,DOM,F) U{sno,name,age} //理解为表的字段(属性)的集合 D{char,int} //理解为表中字段的类型集合 DOM{dom(sno)=dom(name)=char,dom(age)=int} //理解为每个字段具体的取值 F(sno–&gt;name,sno–&gt;age) //理解为表字段的关系 其中F的中元素的意思是，知道了学生的学号(sno)就可以知道学生的姓名(name)和年龄(age)，所以是sno-->name,sno-->age，但因为知道了年龄和姓名不能知道学号，所以不能有name-->sno，age-->sno 关系模式的表示： 5元组R(U,D,DOM,F)R(U,D,DOM,F)R(U,D,DOM,F) 3元组R(U,F)R(U,F)R(U,F) 2元组R(U)R(U)R(U) 3.关系模式与关系的“关系” 关系模式 对关系的描述 静态的、稳定的 关系 关系模式在某一时刻的状态和内容 即关系模式的具体取值 关系模式和关系往往笼统称为关系 1.3 关系数据库 关系数据库 在一个给定的应用领域中，所有关系的集合构成一个关系数据库 关系数据库的型和值 关系数据库的型：关系数据库模式，是对关系数据库的描述，也就是关系模式 关系数据库的值，关系模式在某一时刻对应的关系的集合，通常称为关系数据库 二、关系模型（关系完整性约束） 2.1 实体完整性 关系的主属性不能取空值 例如： 选修(学号，课程号 ,成绩) 其中学号和课程号为候选码，因此两个值都不能取空值 2.2 参照完整性 1. 关系间的引用 示例： 学生（学号，姓名，性别，专业号，年龄） 专业（专业号，专业名） 此时学生关系中引用了专业关系中的主码“专业号”，此时要求学生关系中的“专业号”必须是真实存在的专业号，即能在专业关系中找到该专业号 2.外码 设F是基本关系R的一个或一组属性，但不是关系R的码。 如果F与基本关系S的主码KS相对应，则称F和R的外码 基本关系R称为参照关系 基本关系S称为被参照关系 示例： 学生（学号，姓名，性别，专业号，年龄） 专业（专业号，专业名） “专业号”属性是学生关系的外码 专业关系是被参照关系，学生关系为参照关系 3.参照完整性规则 若属性F是基本关系R的外码，它与基本关系S的主码KS相对应（基本关系R和S可以是同一个关系），则对于R中每个元组在F上的值必须为： 或者取空值 或者等于S中某个元组的主码值 示例： 学生关系的每个元组的“专业号”属性的取值： （1）空值，表示还未给该学生分配专业 （2）非空值，这时该值必须为专业关系中存在的“专业号”值 2.3 用户定义的完整性 即关系模型应提供了自定义完整性规则的接口 示例： 课程(课程号,课程名，学分) 课程号为主码，必须取唯一值 非主属性“课程名”也不能取空值 “学分”属性只能取值{1，2，3，4} 其中“学分”项的取值范围即为自行设定的完整性规则，规定其域。"},{"title":"HTML5学习笔记","date":"2020-03-05T09:50:16.000Z","url":"/2020/03/05/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["HTML","/tags/HTML/"]],"categories":[["HTML","/categories/HTML/"]],"content":"html的入门笔记 学习资料：菜鸟教程 基础框架 头部元素 &lt;title&gt; title标签定义了网页的标题，即在浏览器标签页上显示的内容 &lt;base&gt; &lt;base&gt;标签描述了基本的链接地址，是该HTML文档中所有链接标签的默认链接。 例如在&lt;body&gt;里添加&lt;img src=&quot;logo.png&quot;&gt;，则其链接就相当于 &lt;link&gt; &lt;link&gt;标签用来定义文档与外部资源之间的关系。最常见的用法是链接样式表。 其中rel表示关系这里是stylesheet即样式表，href表示链接文件的路径 所有rel属性值列表 &lt;style&gt; &lt;style&gt;标签定义了HTML文档的样式文件引用地址，也可以在&lt;style&gt;标签中直接添加样式来渲染HTML文档 &lt;meta&gt; &lt;meta&gt;标签用来描述一些基本的元数据，元数据不会显示在页面上，但会被浏览器解析，用于描述页面，例如网页描述、作者、最后修改时间等。 示例： &lt;script&gt; &lt;script&gt;&lt;/script&gt;标签用于定于网页脚本，可以通过src属性指向外部脚本文件，也可以直接在标签内写脚本语句 如果使用\"src\"属性，则< script>元素必须是空的 标题 html中使用&lt;h1&gt;标题文本&lt;/h1&gt;~&lt;h6&gt;标题问题&lt;/h6&gt;来描述6级标题 注释 使用&lt;!-- 注释 --&gt;来进行注释 换行 使用&lt;br /&gt;标签来进行换行 &lt;hr /&gt;可以插入一条水平线，分割距离更大（分得更开） 如上所示 段落 &lt;p&gt;段落&lt;/p&gt;标签表示段落。 HTML中无法识别多个空格和Enter键进行的回车，所有这些操作在html中都会被看成一个空格 因此在段落中如果需要换行，可以添加&lt;br /&gt;标签来进行换行。 段落即&lt;p&gt;&lt;/p&gt;标签会在段落前后自动加上&lt;br /&gt;，对比手动添加&lt;br /&gt;可以发现 在编辑器里尝试。 文本标签 html中提供以下标签来对普通文字（比如这行）进行加粗等操作 显示效果如下： 粗体 斜体 下划线 删除字（中划线） 这是上标 这是下标 着重文字 强调文字 高亮文字 可以发现着重文字和斜体的效果一样，强调文字和粗体的显示效果一样 但 strong 标签代表的是其文字的意义，是需要强调，引起用户注意的。而 b 标签只是代表其文字的样式是粗体也就是CSS中\"font-weight:bold\"的效果，而 strong 标签则可以通过CSS自定义成其他样式 链接 使用&lt;a&gt;&lt;/a&gt;标签来表示 语法： href的参数有一个链接，它可以是具体的网址，也可以是该html中的一个id属性，如果是本页元素的id属性的话，即可实现页面内跳转，此时url=&quot;#id&quot; target的参数表示打开方式，常用的有两个参数，_self在当前标签页打开，_blank在新标签页打开。另有_top参数用来跳出框架，详情见将，_top改为_self即可看出差别。 示例： 新标签页打开百度 当前标签页打开百度 跳转到“文本标签处” 链接文本也可以不是文字，可以是图片或其他html元素 示例： 在编辑器里尝试 &lt;a&gt;标签还可以用来发送邮件(＃°Д°) 在href的参数中输入mailto:balabala@qq.com等即可实现(需要有邮件客户端) 示例： 简单版本 进阶版本 在进阶版本中，cc表示抄送对象邮箱，bcc表示秘密抄送对象的邮箱，subject表示邮件标题，body则是邮件内容。 内联样式 当只有个别HTML元素需要特殊样式渲染时，可以使用内联样式，例如： 这是一个段落 这是一个段落 同样还有其他样式，在CSS里再做讨论 图像 img标签没有结束标签，src表示图像的路径，alt表示的当图片无法加载时，显示的文本，用来告诉用户大概是个什么图片，width和height属性则是指定图片的高度和宽度 创建图像映像 大意就是点击图像中的不同区域，实现不同的效果，就是将图像分成几个不同的区域，各自相应点击事件。详情示例 其中： 表格 表格元素基本框架： 表格用&lt;table&gt;标签来定义，&lt;tr&gt;&lt;/tr&gt;表示一行，&lt;td&gt;&lt;/td&gt;表示该行里的一格,&lt;th&gt;&lt;/th&gt;表示表头，不同&lt;tr&gt;中的&lt;td&gt;数量不等可实现合并单元格，使用cellpadding=&quot;10&quot;来设置10px的格边距，使用border=&quot;1&quot;来添加宽度为1px的边框，使用cellspacing=&quot;10&quot;来添加格与格之间的间距，使用rowspan=&quot;2&quot;来添加纵向两个的合并单元格，使用colspan=&quot;2&quot;来添加横向两个的合并单元格。显示如下 th1 th2 row1,col1 row1,col2 row1,col3 row1,col4 row2,col1 row2,col2 列表 列表分为有序列表和无序列表，有序列表用&lt;ol&gt;&lt;/ol&gt;标签包括，无序标签用&lt;ul&gt;&lt;/ul&gt;标签包括，列表中每一记录用&lt;li&gt;&lt;/li&gt;表示 示例： 显示如下 有序列表： first second third 无序列表 first second third 可以在&lt;ol&gt;&lt;/ol&gt;标签中定义type属性来设置不同的序号，默认为&quot;1,2,3…&quot;，例如设定为&lt;ol type=&quot;A&quot;&gt;&lt;/ol&gt;，显示就会变成&quot;A,B,C,D…&quot;示例 同样，无序列表也可以通过设置对应的style属性来设置不同符号，默认为圆点 圆点值为：list-style-type:disc 空心圆圈值为：list-style-type:circle 方形点值为：list-style-type:square 自定义列表 自定义列表以&lt;dl&gt;&lt;/dl&gt;标签包裹，自定义列表项由&lt;dt&gt;&lt;/dt&gt;标签包裹，自定义列表项的定义由&lt;dt&gt;&lt;/dt&gt;标签包裹。 示例：(以“-”作为序号) Coffee - black hot drink Milk - white cold drink 区块 使用&lt;div&gt;&lt;/div&gt;标签来对页面进行分块，方便布局，并通过&lt;div&gt;&lt;/div&gt;标签来对大块的内容块设置样式属性。 &lt;span&gt;&lt;/span&gt;标签式内联元素，可用作文本的容器，与CSS搭配用于对部分文本设置样式属性 表单元素 &lt;form&gt; &lt;form&gt;&lt;/form&gt;标签用于创建供用户输入的HTML表单 action属性 action属性用于定义在提交表单时执行的动作。链接目标页面，例如： 若省略action属性，则action会被设置为当前页面 &lt;input&gt; &lt;input&gt;标签通过定义不同的type属性可以实现不同的效果 文本框 在多数浏览器中，文本框的默认宽度是20个字符 密码字段 type属性值为password 单选按钮 type属性为radio 选我选我 选他选他 这种情况下我们发现无法实现单选的效果，需要将两个按钮设置相同的name属性，，就可以实现单选效果了。 选我选我 选他选他 复选框 type属性为checkbox i have a bike i have a Car 滑动轴 type属性为range 用max限定最大值，min限定最小值，value设定初始值，step设定步长 按钮 type属性为button 颜色 type属性为color 可以设置value的值来设定初始值 时间 type属性为date 若type属性为month、time、week可有不同的效果 选取文件 type属性为file 使用multiple属性进行多选 数字 type属性为number 用max限定最大值，min限定最小值，value设定初始值，step设定步长 &lt;label&gt; &lt;label&gt;标签用于显示文本，但与普通文本相比，&lt;label&gt;标签可以响应鼠标点击事件 选我选我 选他选他 可与前项对比发现不同 &lt;textarea&gt; &lt;textarea&gt;标签用于创建一个可以拖动扩大缩小的文本框 我是一个文本框 &lt;select&gt;及&lt;datalist&gt; 下拉框选项用&lt;select&gt;标签和&lt;option&gt;标签进行组合 apple banana pear peach 添加multiple属性可以进行多选，添加required属性可以要求必须选择至少一个选项 size属性规定下拉列表中一次性显示的条目数量。 下拉框还可以用&lt;input&gt;和&lt;datalist&gt;标签组合实现 通过在下拉框中添加&lt;optgroup&gt;标签还可以将选项进行分组 Volvo Saab Mercedes Audi &lt;button&gt; 通过&lt;button&gt;标签可以创建一个按钮 点我！ 在 &lt;button&gt; 元素内部可以放置内容，比如文本或图像。这是该元素与使用 &lt;input&gt; 元素创建的按钮之间的不同之处。 通过添加onclick=&quot;xxx()&quot;属性将单击事件与函数xxx()链接起来。 具体事件属性再议。 &lt;fieldset&gt;和&lt;legend&gt; 通过&lt;fieldset&gt;标签对表单中的元素进行分组，即加上一个边框，通过legend标签为该组设定标题 Personalia: Name: Email: Date of birth: 为&lt;fieldset&gt;标签添加disabled属性可以使该分组内元素全部不可更改、 &lt;output&gt; &lt;output&gt;元素跟&lt;form&gt;标签组合进行输出 0 100 + = 视频 使用&lt;video&gt;&lt;/video&gt;标签 controls属性规定了播放视频会不会带有进度条等控制栏内容。 详见链接，与按钮的组合。 音频 使用&lt;audio&gt;&lt;audio&gt;标签 链接"},{"title":"java学习笔记(一)","date":"2020-03-05T06:38:37.000Z","url":"/2020/03/05/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["java","/tags/java/"]],"categories":[["java","/categories/java/"]],"content":"java课程的学习笔记，部分和c++重合的内容不做描述 一、安装java 下载java 去Oracle官网下载。 添加环境变量 在&quot;系统变量&quot;中进行添加 添加JAVA_HOME 选择“新建”，变量名为JAVA_HOME，变量值为jdk的路径，例如C:\\Program Files\\Java\\jdk-12.0.2 添加CLASSPATH 选择“新建”，变量名为CLASSPATH，变量值为.;%JAVA_HOME%\\lib; 添加Path 找到Path项，双击打开（win7等直接在变量值最前面加），选择“新建”，变量值为jdk目录下bin文件夹的路径，例如C:\\Program Files\\Java\\jdk-12.0.2\\bin 测试是否安装成功 打开CMD窗口，输入java -version，有输出则说明安装完成。 二、基本数据类型 分类和长度 与c++一致，其中注意char型 类型 长度 初始值 范围 char 16 bits ‘\\u0000’ ‘\\u0000~\\uffff’ 浮点数 默认为double型 十进制数形式 由数字和小数点组成，且必须有小数点。 如：0.123, 1.23, 123.0 科学计数法形式 如：123e3或123E3，其中e或E之前必须有数字，且e或E后面的指数必须为整数。 float型的值,必须在数字后加f或F,如1.23f。 double型的值,可以在数字后加d或D,如1.23D。 转义符 转义字符 含义 \\n 回车(\\u000a) \\t Tab(\\u0009) \\b 空格(\\u0008) \\r 换行(\\u000d) \\f 换页(\\u000c) \\’ 单引号(\\u0027) \\&quot; 双引号(\\u0022) \\ddd 三位八进制 \\udddd 四位16进制 \\\\ 反斜杠(\\u005c) 三、输入输出 输出 使用System.out.print进行输出 输入 使用输入需要先导入文件，import java.utli.*;或import java.utli.Scanner; 进行使用时，需要先创建Scanner对象 在使用时使用input.next类型()来读取输入内容，例： 四、函数、类格式差异 main函数 java main函数格式为 类 类为 五、数组 数组的复制操作，java提供System.arraycopy函数来进行操作，格式为 System.arraycopy(SourceArray,sourcePositon,DestinationArray,DestinationPositon,number) SourceArray表示被复制的数组，DestinationArray表示复制的数组，即Source-&gt;Destination SourcePosition表示从下标几开始复制，DestinationPosition表示从下标几开始粘贴，number表示复制几位。 示例： 六、向量 向量是java.util包中的一个类，实现了类似 动态数组 的功能，跟数组的区别是向量的容量是 可变 的 向量的容量——向量的存储空间大小（最大下标） 向量的长度——向量的实际元素个数 向量的容量增量——当向量长度达到了容量时，容量的增加量 当容量增量为0时，当向量长度达到容量时，容量变为原来两倍 当容量增量不等于0时，当向量长度达到容量时，新容量=原容量+容量增量 示例： "},{"title":"主题中note提示框的使用","date":"2020-03-04T06:09:24.000Z","url":"/2020/03/04/%E4%B8%BB%E9%A2%98%E4%B8%ADnote%E6%8F%90%E7%A4%BA%E6%A1%86%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["hexo","/tags/hexo/"],["美化","/tags/%E7%BE%8E%E5%8C%96/"]],"categories":[["博客美化","/categories/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"]],"content":"fluid主题中note提示框的挖掘。 Fluid中note提示框的挖掘使用 在一个博客主题中看到了如下的&quot;提示框&quot;效果 就想着能不能在fluid主题中实现类似的效果，按照博客中的教程进行了设置后发现并不能使用，应该是不同主题的缘故。这个想法也就作罢了。 但今天在根据fluid主题在github上的更新记录添加“文章更新时间”功能的时候，发现在post.ejs中使用了一个note-warning的类，原本只是想要修改一下这个note的样式，从黄色调成蓝色，然后在其对应的css文件中（路径：fluid\\source\\lib\\mdbootstrap\\css\\mdb.min.css发现不止有note-waring类，还有note-primary、note-info等一系列类，一想这个跟上图中的提示框的代码相近，会不会有相同的效果？于是进行了尝试，发现果真如此！虽然不能像上图那个博客一样通过下面那种格式来使用 但是在markdown中同样可以通过html的语法来进行调用。 效果依次为： here is note-primary here is note-secondary here is note-success here is note-danger here is note-warning here is note-info here is note-light 具体的样式可以在fluid\\source\\lib\\mdbootstrap\\css\\mdb.min.css搜索note定位后进行修改🤪"},{"title":"Latex的Katex渲染引擎设置","date":"2020-03-03T06:01:40.000Z","url":"/2020/03/03/Latex%E7%9A%84Katex%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%E8%AE%BE%E7%BD%AE/","tags":[["problems","/tags/problems/"],["hexo","/tags/hexo/"]],"categories":[["problems","/categories/problems/"]],"content":"调用katex渲染引擎渲染latex中出现的一些问题 Latex的Katex渲染引擎设置 由于需要在markdown中插入数学公式，因此了解到了Latex，但是在完成了公式的输入后发现hexo中并不能成功渲染Latex公式。为什么呢？这是因为hexo使用自带的hexo-renderer-marked引擎来渲染页面，但是hexo-renderer-marked引擎不能渲染Latex引擎，因此我们需要更换引擎。 供选择的有hexo-renderer-kramed和hexo-renderer-markdown-it-plus 不过由于kramed引擎不能支持markdown all in one中的下标&quot;~ ~“以及 上标”^ ^&quot;这类格式，因此本文使用hexo-renderer-markdown-it-plus引擎 在更换渲染引擎时首先需要先卸载原先的渲染引擎，再安装新引擎 安装kramed的话同理 在安装完引擎后，在fluid的_config.yml中找到math项 将enable的值改为true，engine的值改为katex 由于这里将specific的值设为了true，所以在需要进行数学公式渲染的文章的font-matter中添加一条math: true，采用这种方法可以不影响不需要进行数学公式渲染的页面的加载速度。 这时候再hexo s发现界面中latex公式已经渲染成功了，但是不太美观 这时候还需要在fluid主题下的_static_prefix.yml文件中进行配置 在文件最后找到katex，将其值设为此时再刷新页面即可看到渲染后的数学公式了 若看不到效果的话，依次执行 即可在localhost中看到渲染后的效果"},{"title":"数据库系统原理：第一章绪论","date":"2020-02-28T05:49:53.000Z","url":"/2020/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%AA%E8%AE%BA/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["数据库系统原理","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"categories":[["数据库系统原理","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"]],"content":"数据库系统原理：第一章绪论，包括数据库系统概述、数据模型、数据库系统的结构和数据库系统的组成四部分内容。 一、数据库系统概述 数据库的四个概念 数据（Data） 数据库（DB，Database） 长期存储在计算机内、有组织的、可共享的大量数据的集合 具有最小冗余度是较高的数据独立性 数据库管理系统（DBMS，Database Manage System）功能 是一个位于用户和操作系统之间的基础软件 数据库系统（DBS，Database System） 指在计算机系统引入数据库后的系统构成 在不引起混淆的情况下可称数据库系统为数据库，视语境而言 特点 数据结构化 数据的共享性高，冗余度低且意扩充 数据独立性高 物理独立性 逻辑独立性 数据由数据库管理系统统一管理和控制 其中，DBS包括DB和DBMS DBMS是管理、建立、为何DB的必不可少的软件，一般讲DBMS及其建立的DB总称为DBS 为什么说文件系统中数据操作的效率低。 ——因为文件系统是针对某一特定应用的，所以当我们修改记录的时候，需要在文件中进行对应的修改，还需要考虑不同文件之间的联系，即文件系统的独立性差，所以文件系统中数据操作（比如增、删、改、查）的效率低下。 附：数据管理3个阶段的比较（图源中国大学MOOC中国人民大学相关课程） 二、数据模型 数据模型是数据库系统的核心和基础 2.1 两类数据模型 概念模型/信息模型 按用户的观点来对数据和信息建模，用于数据库设计 逻辑模型 和物理模型 逻辑模型按照计算机系统的观点对数据建模，用于DBMS实现 物理模型描述在系统内（磁盘上）的表示方式和存取方式 2.2 概念模型 基本概念 实体（Entity） 客观存在并可相互区别的事物称为实体，具体的人、事、物或抽象概念 属性（Attribute） 实体所具有的某一特性称为属性 码（Key） 唯一标识实体的属性集称为码 实体型（Entity Type） 用实体名及其属性名集合来抽象和刻画同类实体称为实体型 实体集（Entity Set） 同一类型实体的集合称为实体集 联系（Relationship） 事物 内部联系 以及事物 之间的联系 其中实体之间的联系有一对一(1:1)、一对多(1:m)和多对多(m:n)等类型(一对多可包含一对一) 以上图为例： 概念 —&gt; 所指 实体 —&gt; 学生 属性 —&gt; 学号、姓名、性别… 码 —&gt; 学号 实体型 —&gt; 学生 实体集 —&gt; 学生型的集合 此例中概念所对应的具体意思 实体:现实的一个学生 码:可以唯一确定一个学生的属性——学号 实体型:抽象出这些属性后，用这些属性描述的一个学生实体 概念模型的一种表示方法 实体-联系方法（Entity-Relationship Approach） 例如： 2.3数据模型的组成要素 数据模型由三部分组成 数据结构 数据结构用来描述系统的静态特性 一般什么结构就叫什么模型，例如 层次结构-层次模型、网状结构-网状模型、关系结构-关系模型… 数据操作 数据操作的类型（查询、增删修改等） 数据操作的语言（查询-Query，更新-DML等） 完整性约束 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则 而完整性约束是一组完整性规则的集合 例如退休年龄的限制 2.4层次模型 层次模型用树形结构(类似数据结构中的树)来表示各类实体以及实体间的联系 表示方法 实体型：用记录类型描述 树形：用字段描述 联系：用结点之间的连线表示记录类型之间的一对多的父子联系 定义 满足下面两个条件： 有且只有一个结点没有双亲结点，即根节点 根以外的其他结点有且只有一个双亲结点 优点 层次模型的数据结构比较简单清晰 查询效率高，性能优于关系模型，不低于网状模型 提供了良好的完整性支持 缺点 结点之间的多对多联系表示不自然 对插入和删除操作的限制比较多（相当于数据结构增删结点，要考虑子节点） 查询子女结点必须通过双亲结点（树特点） 2.5网状模型 网状数据库系统采用网状结构来表示各类实体以及实体间的联系 表示方法 和层次结构相同 实体型：用记录类型描述 树形：用字段描述 联系：用结点之间的连线表示记录类型之间的一对多的父子联系 定义 满足下面两个条件： 允许一个以上的结点无双亲 一个结点可以有多于一个的双亲 示例： 优点 更直接地描述现实世界，如一个结点可以有多个双亲，比层次结构更符合实际 具有良好的性能 缺点 结构复杂，尤其是环境扩大时 2.6关系模型 在用户观点下，关系模型中数据的逻辑结构是一张二维表 关系：一个关系对应通常的一张表 元组：表中的一行即为一个元组 属性：表中的一列即为一个属性 主码：也称码键。表中的可以唯一确定一个元祖的某个属性组 域：属性的取值范围(例如学生的“年龄”属性的域为（15-45）) 分量：元组中的一个属性值 关系模式：对关系的描述 关系名（属性1，属性2…，属性n） 学生（学号(主码)，姓名，年龄，系别） 关系必须是规范化的，最基本的规范条件为 每一个分量必须是一个不可分的数据项，即表中不能还有表。 例如工资表，包含职工号、姓名、职称、工资四个属性，若工资在表中又分为基本工资、红利、税收，那么这个“工资”项即使另一份小表，说明该工资表中有表，不是规范关系。 关系模型与常规表格术语对照 关系术语 表格术语 关系名 表名 关系模式 表头（表格的描述） 关系 一张表 元组 记录或行 属性 字段或列 属性名 字段名或列名 属性值 列值 分量 一条记录中一个列值 非规范关系 表中有表（合并单元格） 具体介绍 2.7三种常用模型比较 层次模型 网状模型 关系模型 数据结构 层次结构——树 网状结构——树 关系结构——二维表 数据模型 层次模型 网状模型 关系模型 三、数据库系统的结构 3.1数据库系统模式的概念 模式：一系列关系模式 实例：模式的一个具体值 例： “学生选课数据库”模式：学生、课程和学生选课3个关系模式： 学生表：Student(Sno,Sname,Sage) 课程表：Course(Cno,Cname) 学生选课表：SC(Sno,Cno,Grage) “学生选课数据库”实例： 2019年学生数据库实例 2019年学校所开设的所有课 2019年所有学生选课情况 3.2数据库的三级模式结构 模式（也称逻辑模式） 是数据库中全体数据的逻辑结构和特征的描述 一般，某个应用的数据库只有一个模式 模式是数据库系统模式结构的中心 与数据的物理存储模式以及具体的应用程序开发无关 定义模式 定义数据之间的联系 定义与数据有关的安全性、完整性要求 外模式（也称子模式或用户模式） 是与某一具体应用有关的数据的逻辑表示 外模式通常是模式的子集，一个模式可以有多个外模式 一个外模式可以为多个应用所用，一个应用只能用一个外模式 用途 使用户只能看见和访问所对应外模式中的数据，简化用户视图的同时保证数据库安全 内模式（也称存储模式） 是数据物理结构和存储方式的描述 是数据在数据库内部的表示方式 如存储方式（顺序存储、堆存储…） 数据是否压缩 数据是否加密 … 一个数据库只有一个内模式 3.3数据库的二级映像 三级模式是对数据的三个抽象级别 二级映像是指不同模式之间的转换：外模式-&gt;模式-&gt;内模式 外模式-&gt;模式 定义外模式与模式之间的转换对应关系 因为只有一个模式，有多个外模式，所以数据库中外模式/模式映像是不唯一的 保证逻辑独立性 当模式改变时，不需要修改外模式，只需要修改外模式/模式映像，同时因为外模式不变，所以应用程序也不用进行修改，保证了数据与程序之间的逻辑独立性，简称数据的逻辑独立性 模式-&gt;内模式 定义模式与内模式之间的转换对应关系 因为只有一个模式，一个内模式，所以数据库中模式/内模式映像是唯一的 保证物理独立性 当数据库的存储结构改变了（比如选用另一种存储方式），数据库管理员只需要修改模式/内模式映像，不需要修改模式，模式不变，则应用程序也不变，保证了数据与程序之间的物理独立性，简称数据的物理独立性 四、数据库系统的组成 分为数据库、数据库管理系统、应用程序和数据库管理员 或硬件平台及数据库、软件、人员 其中的人员分可分为数据库管理员、系统分析员和数据库设计人员、应用程序员、最终用户，不同的人员涉及不同的数据抽象级别，具有不同的数据视图 "},{"title":"信安原理第一课","date":"2020-02-27T08:42:26.000Z","url":"/2020/02/27/%E4%BF%A1%E5%AE%89%E5%8E%9F%E7%90%86%EF%BC%9A%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["信安原理","/tags/%E4%BF%A1%E5%AE%89%E5%8E%9F%E7%90%86/"]],"categories":[["信息安全原理","/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86/"]],"content":"信息安全原理第一部分：网络安全威胁 网络安全威胁分类 网络霸权、网络恐怖主义、网络谣言、网络政治动员、网络欺凌、网络攻击和网络犯罪 根据信息流动过程分为四种威胁 中断威胁：(物理破坏系统、破坏网络结构等) 使合法用户不能正常访问网络资源 使有严格时间要求的服务不能及时得到响应 截获威胁：(窃听信息，非法复制程序、数据等) 指一个非授权方介入系统，使得信息在传输中被丢失或泄露的攻击 篡改威胁： 以非法手段窃得对信息的管理权，来篡改信息 伪造威胁： 一个非授权方将伪造的客体插入系统，破坏信息的可认证性 在四种威胁中， 中断威胁破坏信息系统可用性，截获威胁破坏信息保密性， 篡改威胁破坏信息完整性，伪造威胁破坏信息可认证性。"},{"title":"第二章：数据表示与逻辑电路基础","date":"2020-02-26T09:23:21.000Z","url":"/2020/02/26/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"计算机组成原理——第二章：数据表示与逻辑电路基础 包括机器数、定点与浮点数、数据校验、奇偶校验、CRC校验和海明校验等内容 一、机器数及其特点 具体介绍 机器内的数据表示 真值：符号用“+”，“-”表示的数据表示方法 机器数：符号数值化的数据表示方法，用0、1表示符号（二进制） 四种常见的机器数：原码，反码，补码，移码 设定点数的形式为X0X1X2X3...XnX_0X_1X_2X_3...X_nX0​X1​X2​X3​...Xn​ 计算起来就是反码是原码取反（0-&gt;1,1-&gt;0，符号除外） 补码就是反码+1 移码的数值位与补码相同，符号位与补码相反 因此不能说“0”代表正号，“1”代表负号，因为在补码中如此，但在移码中相反 例如： (1)X=+1011 [X]原=[X]反=[X]补=01011 (2)X=-1011 [X]原=11011 [X]反=10100 [X]补=10101 (3)0的表示 [+0]原=00000 [-0]原=10000 [+0]反=00000 [-0]反=11111 [+0]补=00000=[-0]补 机器数表示的范围受字长的限制 原码和反码的0有两种表现形式；补码和移码的0只有1种表现形式 反码的运算 两个二进制数反码相加，最后得到的位数若大于两数的位数，则第一位加至最后一位 例： x=-1101，Y=-1010，则[X+Y]反为 二、定点与浮点数据表示 具体介绍 定点数 可见定点小数的的小数点在数字中间，定点整数的小数点在数字最后 浮点数 浮点数是把数的范围和精度分别表示的一种数据表示方法 一般格式 当计算机的字长确定时，分给阶码部分的位越多，数据表示的范围就越大，与此同时数据的精确度会下降 IEEE 754格式 IEEE 754格式与对应真值之间的变换流程如下 例： 将二进制数20.59375转换成32位IEEE754格式浮点数的二进制格式 IEEE754浮点数ｘｘｘ的二进制存储格式为(41360000)H，其对应的十进制值为？ 小数的原码计算方式： 小数项×2取整数部分，直到小数部分为0 例：0.375的小数表示过程 0.375 * 2 = 0.75 -------------- 0 0.75 * 2 = 1.5 -------------- 1 0.5 * 2 = 1 -------------- 1 所以0.375的二进制表示为.011 反之： 例：.011的十进制表示过程 0 * 10-1 + 1 * 10-2 + 1 * 10-3 =0.375 三、数据校验的基本原理 校验的基本原理是添加冗余码（校验位） 形成 [有效信息(k位)+校验信息(r )位] 的格式 码距：两个合法代码对应位上编码不同的位数称为码距 例如：10101和00110从第一位开始依次有第一位、第四、第五位不同，则码距为3 一组数中取码距最小的两对数的码距 码距 检错 纠错 1 0 0 2 1 0 3 2 或1 4 2 加1 5 2 加2 6 3 加2 7 3 加3 … 三个公式： 码距&gt;=eee+1 ——&gt;可检测e个错误 码距&gt;=2ttt+1 ——&gt;可纠正t个错误 码距&gt;=eee+ttt+1 ——&gt;可纠正t个错误，同时检测e个错误（e&gt;=t） 四、奇偶校验 基础知识 奇偶校验的原理同样是通过增加冗余码（校验位）来进行错误校验，奇偶校验的冗余码位数为一， 形成 [有效信息(k位)+校验信息(r=1)位] 的格式 通过增加的这个冗余码，使得整个编码中1的个数满足奇/偶校验的要求，如下 0001-&gt;00011 (偶校验) P=DP=DP=D1⊕D⊕D⊕D1⊕D⊕D⊕D2⊕D⊕D⊕D3⊕D⊕D⊕Dn 0001-&gt;00010 (奇校验) P=P=P= D1⊕D2⊕D3⊕Dn‾\\overline{D_1⊕D_2⊕D_3⊕D_n}D1​⊕D2​⊕D3​⊕Dn​​ 第一个式子中总共有两个1，所以是偶校验，第二个式子中总共有一个1，所以是奇校验 奇偶校验的编码与检错简单，编码效率高，但是它不能检测偶数位错误，所以它的无措结论是不可靠的，但是只有一位编码错误的时候，奇偶校验的检错率是100%，肯定能够检测出来。 奇偶校验只能检测一位错误，并且没有纠错能力，因此奇偶校验的码距是2 改进的奇/偶校验 改进后的奇/偶校验又称为双向奇偶校验、方块校验、垂直水平校验等 即在原有的一列奇偶校验码的基础上再添加一行奇偶校验码 这种校验方式可以检测并纠正一位错误，可以检测某行（列）上的奇数位错误，可以检测出一部分偶数位错误，不能检测出分布在矩形四个顶点上的错误。 一般在同步传输方式中常采用奇校验，异步传输中常采用偶校验 五、CRC校验（循环冗余校验） 基础知识 CRC校验的校验码的位数由一个公式得到N=k+r≤2r−1N=k+r\\leq2^r-1N=k+r≤2r−1，其中 rrr表示校验位数 kkk表示有效信息位数 2r−12^r-12r−1表示可以表现的错误总数（总共2r2^r2r种情况，其中一种是正确无错误） 格式仍然为 [有效信息(k位)+校验信息(r )位] CRC校验中存在一个生成多项式G(x)G(x)G(x),概念为:收发双方约定的一个 (r+1) 位二进制数，发送方利用G(x)G(x)G(x)对信息多项式做模2除运算，生成校验码。接收方利用G(x)G(x)G(x)对收到的编码多项式做模2除运算检测差错及错误定位 G(x)G(x)G(x)应该满足以下特点 最高位和最低位必须为1 当被传送信息（CRC码）任何一位发生错误时，被生成多项式做除后应该使余数不为0 不同位发生错误时，模2除运算后余数不同 对不为0余数继续进行模2除运算应使余数循环 以下为常见的生成多项式G(x)G(x)G(x) (N=k+r) N K 码距d G(x)多项式 G(x) 7 4 3 x2+x+1x^2+x+1x2+x+1 1011 7 4 3 x3+x2+1x^3+x^2+1x3+x2+1 1101 7 3 4 x4+x3+x2+1x^4+x^3+x^2+1x4+x3+x2+1 11101 7 3 4 x4+x2+x2+x+1x^4+x^2+x^2+x+1x4+x2+x2+x+1 10111 15 11 3 x4+x+1x^4+x+1x4+x+1 10011 15 7 5 x8+x7+x6+x4+1x^8+x^7+x^6+x^4+1x8+x7+x6+x4+1 111010001 31 26 3 x5+x2+1x^5+x^2+1x5+x2+1 100101 31 21 5 x10+x9+x8+x6+x5+x3+1x^{10}+x^9+x^8+x^6+x^5+x^3+1x10+x9+x8+x6+x5+x3+1 11101101001 63 57 3 x6+x+1x^6+x+1x6+x+1 1000011 63 51 5 x12+x10+x5+x4+x2+1x^{12}+x^{10}+x^5+x^4+x^2+1x12+x10+x5+x4+x2+1 1010000110101 一般情况下使用的都是1011 模2除运算 加/减运算（异或运算，相同为0，不同为1） 0 ±\\pm± 0=0，0 ±\\pm± 1=1，1 ±\\pm± 0=1，1 ±\\pm± 1=0 模2除法（见下） CRC编码 根据待校验信息的长度kkk，按照 k+r≤2r−1k+r\\leq2^r-1k+r≤2r−1 确定校验位rrr的位数 如对4位信息1100进行CRC编码，根据公式得rmin=3 根据rrr和生成多项式得选择原则，选择位数为r+1r+1r+1的生成多项式G(x)=1011 进行下列变化 [有效信息(k位)+校验信息(r 位)] —&gt; 1100 000 即先把校验位全设0，得Q(x) 对得到的Q(x)进行模2除运算 用得到的余数替换校验位，得到最后的CRC编码为 [有效信息(k位)+校验信息(r 位)] —&gt; 1100 000 —&gt; 1100 010 CRC检错与纠错 对得到校验码(即二进制编码数)，用G(x)作模2除，若得到一个不为0的余数，则说明信息出错了。 进行纠错 若余数不为0，若余数首位为1，则补零进行模2除，得到余数；若余数首位为0，则其剩下三位为余数，同时将被检测的校验码循环左移一位，由此得到第二个余数，直到余数为101时，说明此时的出错位已经移动到了最左端，将此时校验码的最左端数字取反，然后继续循环左移，直到移动位数之和为7，说明纠错完毕，出错位回到原位。例如一开始移动了4位，取反后继续移动3位。具体示例如下： 进行模2除运算得到的余数是循环的，顺序为：011-&gt;110-&gt;111-&gt;101-&gt;001-&gt;010-&gt;100-&gt;011 CRC校验得到的无措结论不一定是正确的 六、海明校验 海明校验的格式跟CRC校验相同 CRC校验的校验码的位数由一个公式得到N=k+r≤2r−1N=k+r\\leq2^r-1N=k+r≤2r−1，其中 rrr表示校验位数 kkk表示有效信息位数 2r−12^r-12r−1表示可以表现的错误总数（总共2r2^r2r种情况，其中一种是正确无错误） 在海明编码中存在两种数据，分别称为校验位和数据位，其中校验位的位数为rrr所表示的数字，设k+rk+rk+r位海明码从左到右依次为第1，2，3，4…k+r位，r位校验位记为PiP_iPi​(i=1,2,3…,r)，分别位于k+r位海明编码的第 2i-1(i=1,2,3…,r)位上，其余位依次放置被校验的数据位，记为bib_ibi​(i=1,2,3…,r) 例如：海明校验码中校验位和数据位的排列如下 HjH_jHj​位的数据被编号小于j的若干个海明位号之和等于j的校验位所校验，如： Hi 1 2 3 4 5 6 7 8 9 10 11 1 2 1,2 4 1,4 2,4 1,2,4 8 1,8 2,8 1,2,8 P1 P2 b1 P3 b2 b3 b4 P4 b5 b6 b7 得出：任何一位有效数据位至少被两位校验位所校验 用偶校验计算出P1P_1P1​~P4P_4P4​四个校验位的值： P1=b1 ⊕⊕⊕ b2 ⊕⊕⊕ b4 ⊕⊕⊕ b5 ⊕⊕⊕ b7 P2=b1 ⊕⊕⊕ b3 ⊕⊕⊕ b4 ⊕⊕⊕ b6 ⊕⊕⊕ b7 P3=b2 ⊕⊕⊕ b3 ⊕⊕⊕ b4 P4=b5 ⊕⊕⊕ b6 ⊕⊕⊕ b7 指错字G由校验位和被其校验的数据位依次做异或运算得到。 得指错字G4G3G2G1为： G4=P4 ⊕⊕⊕ b5 ⊕⊕⊕ b6 ⊕⊕⊕ b7 G3=P3 ⊕⊕⊕ b2 ⊕⊕⊕ b3 ⊕⊕⊕ b4 G2=P2 ⊕⊕⊕ b1 ⊕⊕⊕ b3 ⊕⊕⊕ b4 ⊕⊕⊕ b6 ⊕⊕⊕ b7 G1=P1 ⊕⊕⊕ b1 ⊕⊕⊕ b2 ⊕⊕⊕ b4 ⊕⊕⊕ b5 ⊕⊕⊕ b7 若G4G3G2G1为0，则表明数据没有出错，反之其十进制值为出错的海明吗位号。例题如下： 如上图所示的H=01100110000为例 指错字G4G3G2G1=0000，不一定说明无错 例如P1、b1、P2三位同时出错，则G4G3G2G1依然为0 一位错和两位错不能由指错字区别 如b1、b2同时出错，与仅b3出错时的指错字均为G4G3G2G1=0110 "},{"title":"第一章：计算机系统概论","date":"2020-02-24T06:16:42.000Z","url":"/2020/02/24/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机组成原理","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"categories":[["计算机组成原理","/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"]],"content":"计算机组成原理——第一章：计算机系统概论笔记 包括冯·诺依曼结构和计算机系统性能评价两大块内容 冯·诺依曼结构 一、 工作原理 存储程序 程序控制 二、计算机组成 硬件系统 主机:CPU（运算器+控制器）、内存 算术运算：加减乘除等 逻辑运算：与或非等 基本结构：算术逻辑运算单元（ALU）、计算用累加器、保存结果用寄存器 控制器：更新 基本功能：控制指令的执行，依据指令产生控制信号（电平信号、脉冲信号） 产生控制信号的依据：指令、状态、时序 产生方式：微程序、硬布线 存储器： 基本结构：地址总线、存储体、数据总线 功能：存储原程序、原数据和运算中间结构 工作模式：读/写 工作原理：按地址访问、读/写数据 容量 地址线数量 1k 10 1M 20 1G 30 例题：访问2Gb容量的空间，需要的地址线数量为？ 因为2¹=2，所以数量为30+1=31根 230=1GB，表示有230个地址，但2Gb时230个地址不够用（1字节一个地址），所以需要231个地址 CPU执行一条指令通常存在两个过程，分别是取指阶段和执行阶段，在取指阶段访问存储器读取指令，执行阶段访问存储器读取数据，所以虽然指令和数据都是二进制表示，但CPU能够加以区分。 2. 外设：输入设备、输出设备、外存储器 3. 总线： 能为系统中多个部件分时 共享的一组 信息传输线 及 相关逻辑 共享：总线所连的各部件通过它来传递信息。 分时：某一时刻只允许一个部件向总线发送信息。 就所有部件都通过总线来传送信息，若可以同时传输信息的话，假如A部件需要传输一个高电平信号，部件B传输一个低电平信号，那么就无法判断到底是高点平信号还是低电平信号。 如何实现分时传输信号呢？在数字电路中通过三态门来进行这一操作。 三态门通过&quot;输出使能&quot;来使这一路获得除高低外的第三态——高阻态，即阻值巨大相当于断路。 这样在硬件不使用时，通过输出使能让该路形成“伪断路”，不向总线传输信息，在使用时，让该路恢复，正常传输信息 总线的分类： 总线信号可以分成三组： 地址总线AB：传送地址信息 输出将要访问的内存单元或I/O端口的地址 地址线的多少决定了系统能够直接使用的最大的存储容量一般为单向，由CPU输出 数据总线DB：传送数据信息 CPU读操作时，外部数据通过数据总线送往CPU CPU写操作时，CPU数据通过数据总线送外外部 数据线的多少决定了一次能够传送数据的位数双向，即可由CPU向外也可由外向CPU 控制总线CB：传送控制信息 包括CPU送出的控制信号和主存或外设给CPU的反馈信号（双向） 此外总线还包括电源、地线等其他辅助信号。 软件系统 表现形式：程序和数据 核心：算法 软/硬件关系 相互依存 逻辑等效性：某些功能可以由硬件实现，也可以由软件实现 协同发展 三、计算机层次结构 计算机层次结构从上到下依次为： 应用程序 高级语言 汇编语言 操作系统 指令集架构层 微代码层 硬件逻辑层 在计算机的层次结构中，上下层是可以分割的，仅有下层而没有上层是可行的。上层是下层的功能实现，上层在下层的基础上实现更丰富的功能。 计算机系统性能评价 一、非时间指标 机器字长：指机器一次能处理的二进制位数 总线宽度：数据总线一次能并行传送的最大信息位数 主存容量：指一台计算机主存所包含的存储单元总数 存储带宽：指单位时间内与主存交换的二进制信息量 二、时间指标 主频 fff / 时间周期 TTT ，外频，倍频 主频f:指CPU内核工作的时钟频率，即CPU内数字脉冲信号振荡的速率 时钟周期T:计算机中最基本最小的时间单位，是CPU中两个功能部件之间传递信息所需要的最短时间 在一个时钟周期内，CPU仅能完成一个最基本的动作 外频：指CPU与主板之间同步的时钟频率 倍频：CPU主频与外频之间的倍数 主频=外频 * 倍频 例：奔腾4 2.4GCPU 主频2400M = 133M（外频）x 18（倍频） CPI(Clock cycle Per Instruction) 指执行一条指令平均需要的时钟周期数 计算方法 CPI=程序中所有指令的时钟周期之和/程序中指令总数 =∑(程序中各类指令的CPI x 程序中该指令的比例) 例： 指令类型 CPI 指令比例 算术和逻辑 1 60% Load/Store 2 18% 转移 4 12% Cache缺失访存​​​​ 8 10% CPI=1*60%+2*18%+4*12%+8*10%=2.24​​ MIPS(Million Instructions Per Second) 每秒钟CPU能执行的指令条数（单位：百万条/秒） 计算方法 主频/(CPI ∗*∗ 106)(全性能公式) CPI不变时，主频率越高，运行速度就越快。 例: 某计算机主频为1GHz，总指令数为2*10^5，比例如下 指令类型 CPI 指令比例 算术和逻辑 1 60% Load/Store 2 18% 转移 4 12% Cache缺失访存​​​​ 8 10% MIPS=fff/(CPI*106)=​​446.4 CPU时间 执行一段程序所需的时间：CPU时间+I/O时间+存储访问时间+各类排队时延等 计算方法： 程序中所有指令的时钟周期数之和∗*∗TTT 程序中所有指令的时钟周期数之和///fff 总指令数*CPI*T 指令数量/(MIPS*106) 例: 某计算机主频为1GHz，总指令数为2*10^5，比例如下 指令类型 CPI 指令比例 算术和逻辑 1 60% Load/Store 2 18% 转移 4 12% Cache缺失访存​​​​ 8 10% 一：基于CPI CPU时间=2*105*CPI///fff=（2*105*2.24/109)=4.48*10-4(秒) 二：基于MIPS CPU时间​​​=2*105/(MIPS*106)=4.48*10-4(秒)​​​​ 更新内容 控制器详解 "},{"title":"fluid个性化","date":"2020-02-24T02:23:23.000Z","url":"/2020/02/24/fluid%E4%B8%AA%E6%80%A7%E5%8C%96/","tags":[["hexo","/tags/hexo/"],["美化","/tags/%E7%BE%8E%E5%8C%96/"]],"categories":[["博客美化","/categories/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"]],"content":"各类参数的修改位置及作用、网页音乐播放器、评论模块、一言的调用等… fluid个性化及小插件的使用 网页标题浏览器恶搞 在\\themes\\fluid\\source\\js 下创建一个新的js文件，例如FunnyTitle.js，输入如下内容： 之后在\\themes\\fluid\\layout.ejs中末尾输入 fluid鼠标点击效果更改 fluid主题的鼠标特效在\\themes\\fluid\\layout\\_partial\\plugins\\mouse-click.ejs中，找到如下图所示的代码 将数组中的字符串进行更改即可进行自定义 然后在主题配置（即fluid的_config.yml）中将mouse-clik项的style改为values 一言 一言官网 根据官网提供的示例，在\\themes\\fluid\\layout\\layout.ejs中添加如下代码 然后在任意想要加入一言的位置添加 例如我在页面的最底部，即hexo❤Fluid下方加入一言，即在\\themes\\fluid\\layout\\_partial\\footer.ejs中加入该行代码。在页面中显示的具体位置由代码所在位置决定。 一言官网举例了几个网址供读取信息 在本部分第一个代码块中将对应的网址更改即可，同样可以通过“&amp;”的方式指定多个特定的类型 参数列表如下，通过c=xx来使用 参数 描述 C a Anime - 动画 b Comic – 漫画 c Game – 游戏 d Novel – 小说 e Myself – 原创 f Internet – 来自网络 g Other – 其他 音乐播放插件 这里使用的是插件是APlayer 🎶Wow, such a beautiful HTML5 music player 原本用的是网易云的的外链播放器，然鹅！网易云几乎所有的歌都因版权问题无法生成外链播放器，即使通过一些方法生成了也无法播放，因此采用了APlayer。 首先安装Aplayer 我因为网络的问题替换了成了淘宝的镜像，若没有设置过直接使用npm即可。 在想要加入网页播放器的地方输入以下代码 例如我将播放器加入到“关于”界面，就在\\themes\\fluid\\layout\\about.ejs中加入这段代码，在这里我将代码嵌入跟原有代码进入了稍微的整合，使结构清晰。 在上述代码的script块中，autoplay是自动播放，改为true则会在打开该页面时自动播放。 在网页版网易云音乐搜索歌曲，打开后将网址的最后一串数字替换到url中对应的数字部分即可更换歌曲 歌曲封面由pic字段决定，同样在网页版网易云音乐界面，在F12开发者模式中选中歌曲封面区域即可得到封面链接，替换至pic区域即可。歌词来自 参考网址： 背景添加动态线条 在\\theme\\fluid\\layout\\layout.ejs文件中添加如下代码 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 转自TRHX博客 网站运行时间 在\\themes\\fluid\\layout\\_partial\\footer.ejs中添加以下代码 转自 THRX博客 -www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/#【10】添加网站运行时间"},{"title":"Failed to connect to github.com port 443: Timed out","date":"2020-02-22T14:54:17.000Z","url":"/2020/02/22/hexo-Failed-to-connect-to-github-com-port-443-Timed-out/","tags":[["problems","/tags/problems/"],["git","/tags/git/"],["hexo","/tags/hexo/"]],"categories":[["problems","/categories/problems/"]],"content":"Failed to connect to github.com port 443: Timed out Failed to connect to github. com port 443: Timed out 在使用hexo g -d部署到github上时出现了“Failed to connect to github. com port 443: Timed out”的错误提示。 解决办法 输入 "},{"title":"Hello World","date":"2020-02-21T09:24:43.209Z","url":"/2020/02/21/hello-world/","tags":[["hexo","/tags/hexo/"]],"categories":[[" ",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post More info: Writing Run server _[HTML]: Hyper Text Markup Language More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake dfadf"},{"title":"关于我","date":"2020-04-25T05:46:23.000Z","url":"/about/index.html","categories":[[" ",""]],"content":"欢迎来到这个博客~ 我喜欢星空，浩瀚的夜空中闪烁着无数的星星，躺在清晰可见的银河之下，会是一幅多么美妙的画面。而一座不大不小的小屋子，给人温馨和安全感。在美好的环境下享受自在的感觉会是一种多么美妙的体验。 很久以前就想着搞个博客玩玩，当然主要是觉得很有意思，以前也用hexo做过一个博客，不过可能因为也不知道写些什么吧，就慢慢荒废了，这次又重新弄起来了，既然不知道写些什么就记些笔记吧😂 看笔记内容也看得出来了，一个在校大学生，软件工程专业。沉迷爱玩游戏，莫得钱购买主机，更莫得钱购买主机游戏，再加上手柄操作不惯，所以是个PC党。近期主要在玩彩虹六号，萌新一个，蒟蒻。😑 喜欢摄影，喜欢旅游，不过还是因为莫得钱╮(╯_╰)╭，所以也没有怎么实行。偏向自然景观，对人文景观缺乏欣赏能力 _(:3」∠)_ 先这样吧，加油啊┗|｀O′|┛ ~~"},{"title":"tags","date":"2020-09-22T14:20:16.000Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"search","date":"2020-09-22T14:25:40.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"friends","date":"2020-09-22T14:24:34.000Z","url":"/friends/index.html","categories":[[" ",""]]}]